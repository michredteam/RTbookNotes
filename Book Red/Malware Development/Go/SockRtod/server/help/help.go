package help

import (
	"crypto/sha256"
	"crypto/tls"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	//"fmt"
	aesgo "github.com/3xploit666/AesGo"
	"github.com/fatih/color"
	"github.com/hashicorp/yamux"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net"
	"os"
	"os/signal"
	"sync"
	"time"
)

var sSession *yamux.Session

// Catches yamux connecting to us
func RemoteListener(bindAddress, tlsCert, tlsKey string) {

	log.Println("Waiting for remote reverse connection client: ", bindAddress)

	cert, err := tls.LoadX509KeyPair(tlsCert, tlsKey)
	if err != nil {
		log.Fatal("Error: ", err)
	}

	ln, err := tls.Listen("tcp", bindAddress, &tls.Config{Certificates: []tls.Certificate{cert}})
	if err != nil {
		log.Fatal("Error: ", err)
	}

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Print(err)
			continue
		}

		log.Println("Remote client connected: ", conn.RemoteAddr())

		// Add connection to yamux
		sSession, err = yamux.Client(conn, nil)
	}
}

// Catches clients and connects to yamux
func SocksListener(bindAddress string) {

	log.Println("Waiting for socks client: ", bindAddress)

	ln, err := net.Listen("tcp", bindAddress)
	if err != nil {
		log.Fatal("Error: ", err)
	}

	for {

		conn, err := ln.Accept()
		if err != nil {
			log.Fatal("Error: ", err)
		}

		if sSession == nil {
			log.Printf("Rejecting incoming socks connection (%s), remote session not connected", conn.RemoteAddr())
			conn.Close()
			continue
		}

		//	log.Println("Got a socks client: ", conn.RemoteAddr())

		stream, err := sSession.Open()
		if err != nil {
			log.Fatal("Error: ", err)
		}

		// connect both of conn and stream

		var endWaiter sync.WaitGroup
		endWaiter.Add(2)

		go func() {
			defer conn.Close()
			defer endWaiter.Done()
			io.Copy(conn, stream)
		}()

		go func() {
			defer stream.Close()
			defer endWaiter.Done()
			io.Copy(stream, conn)
		}()

		go func() {
			endWaiter.Wait()
			//log.Printf("Socks connection (%s) ended", conn.RemoteAddr())
		}()

	}
}

var src = rand.NewSource(time.Now().UnixNano())

const letterBytes = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
const (
	letterIdxBits = 6                    // 6 bits to represent a letter index
	letterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
	letterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits
)

func RandStringBytesMaskImprSrc(n int) string {
	b := make([]byte, n)
	// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!
	for i, cache, remain := n-1, src.Int63(), letterIdxMax; i >= 0; {
		if remain == 0 {
			cache, remain = src.Int63(), letterIdxMax
		}
		if idx := int(cache & letterIdxMask); idx < len(letterBytes) {
			b[i] = letterBytes[idx]
			i--
		}
		cache >>= letterIdxBits
		remain--
	}

	return string(b)
}

func PrintClientConfigKey(connectBackAddress, tlsCert string) {

	pemBytes, err := ioutil.ReadFile(tlsCert)
	if err != nil {
		log.Print("TLS cert error: ", err)
		log.Print("Genere certificados" +
			"$ openssl req -x509 -nodes -newkey rsa:4096 -keyout key.pem -out cert.pem -days 90")
		os.Exit(1)
	}
	block, _ := pem.Decode(pemBytes)

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		log.Fatal("TLS cert error: ", err)
	}

	pubkey, _ := x509.MarshalPKIXPublicKey(cert.PublicKey)
	hash := sha256.Sum256(pubkey)

	var addrBytes []byte
	addrBytes = []byte(connectBackAddress)
	clientConfig := hex.EncodeToString(append(hash[:], addrBytes...))
	key := RandStringBytesMaskImprSrc(20)
	color.Red("key [+] %s", key)

	cipher := aesgo.EncryptAes(clientConfig, key)

	color.Green(cipher)

}

func WaitForCtrlC() {
	var endWaiter sync.WaitGroup
	endWaiter.Add(1)
	var signalChannel chan os.Signal
	signalChannel = make(chan os.Signal, 1)
	signal.Notify(signalChannel, os.Interrupt)
	go func() {
		<-signalChannel
		endWaiter.Done()
	}()
	endWaiter.Wait()
}
