#include <windows.h>
#include <iostream>
#include <string>
#include <shlwapi.h>
#include <psapi.h>
#include <stdio.h>
#include "resolve.h"

#define NT_SUCCESS(x) ((x) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004
#define SystemHandleInformation 16
#define ObjectBasicInformation 0
#define ObjectNameInformation 1
#define ObjectTypeInformation 2

using namespace std;
class MemoryHandlersClass{     
public:
    MemoryHandlersClass(){
    };
    PSYSTEM_HANDLE_INFORMATION MapMemoryHandlers(){
        NTSTATUS status;
        ULONG handleInfoSize = 0x10000;
        PSYSTEM_HANDLE_INFORMATION handleInfo;
        // Resolve NtQuerySystemInformation, NtDuplicateObject, NtQueryObject
        pNtQuerySystemInformation = (NtQuerySystemInformation_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
        // Allocate memory for handle information
        handleInfo = (PSYSTEM_HANDLE_INFORMATION) malloc(handleInfoSize);
        
        while(status = pNtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, NULL) == STATUS_INFO_LENGTH_MISMATCH){
            handleInfoSize *= 2;
            handleInfo = (PSYSTEM_HANDLE_INFORMATION) realloc(handleInfo, handleInfoSize);
        }
        return handleInfo;
    }
    void FilterForFileHandlers(PSYSTEM_HANDLE_INFORMATION memoryHandlers){
        pNtDuplicateObject = (NtDuplicateObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtDuplicateObject");
        pNtQueryObject = (NtQueryObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryObject");
        HANDLE hProcess;
        char procHostPath[MAX_PATH];
        NTSTATUS status;
        ULONG i;
        char procNameTemp[MAX_PATH];
        // printf(memoryHandlers->NumberOfHandles);
        cout << "Process Name" << "\t" << "Process ID" << "\t" << "Handle Value" << "\t" << "Granted Access" << "\t" << "Handle Type" << "\t" << endl;          
        cout << "------------" << "\t" << "----------" << "\t" << "------------" << "\t" << "-------------" << "\t" << "-----------" << "\t" << endl;
        for(i=0; i < memoryHandlers->NumberOfHandles; i++){
            SYSTEM_HANDLE_TABLE_ENTRY_INFO handle = memoryHandlers->Handles[i];
            HANDLE duplicatedHandle = NULL;
            POBJECT_TYPE_INFORMATION objectTypeInfo;
            PVOID objectNameInfo;
            UNICODE_STRING objectName;
            ULONG returnLength;
            if(!(hProcess = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, handle.UniqueProcessId))){
                //cout << "Failed to open process" << endl;
                continue;                
            }
            GetProcessImageFileNameA(hProcess,procHostPath,MAX_PATH);
            NTSTATUS status = pNtDuplicateObject(hProcess, (void *) handle.HandleValue, GetCurrentProcess(), &duplicatedHandle, 0, 0, DUPLICATE_SAME_ACCESS);
            if (!NT_SUCCESS(status)) {
                CloseHandle(hProcess);
                continue;
            }
            
            objectTypeInfo = (POBJECT_TYPE_INFORMATION) malloc(0x1000);
            if (status=(pNtQueryObject(duplicatedHandle, ObjectTypeInformation, objectTypeInfo, 0x1000, &returnLength))){
                //cout << status << endl;
                CloseHandle(hProcess);
                continue;   
            }
            objectNameInfo = malloc(0x1000);
            if(!NT_SUCCESS(pNtQueryObject(duplicatedHandle, ObjectNameInformation, objectNameInfo, 0x1000 ,&returnLength))){    
                objectNameInfo = realloc(objectNameInfo, returnLength);
            }
            objectName = *(PUNICODE_STRING) objectNameInfo;
            int procID = 0;
            if (objectName.Length) {
                // The object has a name.
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                if (wcscmp(handleType, L"File") == 0) {
                //printf("%.*S\n", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S [PID:%#5d : %s]\n",
                  PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                  handle.HandleValue,
                  handle.Object,
                  handle.GrantedAccess,    
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    objectName.Length / 2,    
                    objectName.Buffer,
                  procID,
                  (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }    
            }
            else {
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                // The object has no name.
                if (wcscmp(handleType, L"File") == 0) {
                    printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: (unnamed)\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: [PID:%#5d : %s]\n",
                    PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                    handle.HandleValue,
                    handle.Object,
                    handle.GrantedAccess,
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    procID,
                    (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }                
            }
        }
    }
        
    void FilterForProcessHandlers(PSYSTEM_HANDLE_INFORMATION memoryHandlers){
        pNtDuplicateObject = (NtDuplicateObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtDuplicateObject");
        pNtQueryObject = (NtQueryObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryObject");
        HANDLE hProcess;
        char procHostPath[MAX_PATH];
        NTSTATUS status;
        ULONG i;
        char procNameTemp[MAX_PATH];
        // printf(memoryHandlers->NumberOfHandles);
        cout << "Process Name" << "\t" << "Process ID" << "\t" << "Handle Value" << "\t" << "Granted Access" << "\t" << "Handle Type" << "\t" << endl;          
        cout << "------------" << "\t" << "----------" << "\t" << "------------" << "\t" << "-------------" << "\t" << "-----------" << "\t" << endl;
        for(i=0; i < memoryHandlers->NumberOfHandles; i++){
            SYSTEM_HANDLE_TABLE_ENTRY_INFO handle = memoryHandlers->Handles[i];
            HANDLE duplicatedHandle = NULL;
            POBJECT_TYPE_INFORMATION objectTypeInfo;
            PVOID objectNameInfo;
            UNICODE_STRING objectName;
            ULONG returnLength;
            if(!(hProcess = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, handle.UniqueProcessId))){
                //cout << "Failed to open process" << endl;
                continue;                
            }
            GetProcessImageFileNameA(hProcess,procHostPath,MAX_PATH);
            NTSTATUS status = pNtDuplicateObject(hProcess, (void *) handle.HandleValue, GetCurrentProcess(), &duplicatedHandle, 0, 0, DUPLICATE_SAME_ACCESS);
            if (!NT_SUCCESS(status)) {
                CloseHandle(hProcess);
                continue;
            }
            
            objectTypeInfo = (POBJECT_TYPE_INFORMATION) malloc(0x1000);
            if (status=(pNtQueryObject(duplicatedHandle, ObjectTypeInformation, objectTypeInfo, 0x1000, &returnLength))){
                //cout << status << endl;
                CloseHandle(hProcess);
                continue;   
            }
            objectNameInfo = malloc(0x1000);
            if(!NT_SUCCESS(pNtQueryObject(duplicatedHandle, ObjectNameInformation, objectNameInfo, 0x1000 ,&returnLength))){    
                objectNameInfo = realloc(objectNameInfo, returnLength);
            }
            objectName = *(PUNICODE_STRING) objectNameInfo;
            int procID = 0;
            if (objectName.Length) {
                // The object has a name.
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                if (wcscmp(handleType, L"Process") == 0) {
                //printf("%.*S\n", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S [PID:%#5d : %s]\n",
                  PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                  handle.HandleValue,
                  handle.Object,
                  handle.GrantedAccess,    
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    objectName.Length / 2,    
                    objectName.Buffer,
                  procID,
                  (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }    
            }
            else {
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                // The object has no name.
                if (wcscmp(handleType, L"Process") == 0) {
                    printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: (unnamed)\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: [PID:%#5d : %s]\n",
                    PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                    handle.HandleValue,
                    handle.Object,
                    handle.GrantedAccess,
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    procID,
                    (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }
            }
        }
    }
    void FilterForKeyHandlers(PSYSTEM_HANDLE_INFORMATION memoryHandlers){
        pNtDuplicateObject = (NtDuplicateObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtDuplicateObject");
        pNtQueryObject = (NtQueryObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryObject");
        HANDLE hProcess;
        char procHostPath[MAX_PATH];
        NTSTATUS status;
        ULONG i;
        char procNameTemp[MAX_PATH];
        // printf(memoryHandlers->NumberOfHandles);
        cout << "Process Name" << "\t" << "Process ID" << "\t" << "Handle Value" << "\t" << "Granted Access" << "\t" << "Handle Type" << "\t" << endl;          
        cout << "------------" << "\t" << "----------" << "\t" << "------------" << "\t" << "-------------" << "\t" << "-----------" << "\t" << endl;
        for(i=0; i < memoryHandlers->NumberOfHandles; i++){
            SYSTEM_HANDLE_TABLE_ENTRY_INFO handle = memoryHandlers->Handles[i];
            HANDLE duplicatedHandle = NULL;
            POBJECT_TYPE_INFORMATION objectTypeInfo;
            PVOID objectNameInfo;
            UNICODE_STRING objectName;
            ULONG returnLength;
            if(!(hProcess = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, handle.UniqueProcessId))){
                //cout << "Failed to open process" << endl;
                continue;                
            }
            GetProcessImageFileNameA(hProcess,procHostPath,MAX_PATH);
            NTSTATUS status = pNtDuplicateObject(hProcess, (void *) handle.HandleValue, GetCurrentProcess(), &duplicatedHandle, 0, 0, DUPLICATE_SAME_ACCESS);
            if (!NT_SUCCESS(status)) {
                CloseHandle(hProcess);
                continue;
            }
            
            objectTypeInfo = (POBJECT_TYPE_INFORMATION) malloc(0x1000);
            if (status=(pNtQueryObject(duplicatedHandle, ObjectTypeInformation, objectTypeInfo, 0x1000, &returnLength))){
                //cout << status << endl;
                CloseHandle(hProcess);
                continue;   
            }
            objectNameInfo = malloc(0x1000);
            if(!NT_SUCCESS(pNtQueryObject(duplicatedHandle, ObjectNameInformation, objectNameInfo, 0x1000 ,&returnLength))){    
                objectNameInfo = realloc(objectNameInfo, returnLength);
            }
            objectName = *(PUNICODE_STRING) objectNameInfo;
            int procID = 0;
            if (objectName.Length) {
                // The object has a name.
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                if (wcscmp(handleType, L"Key") == 0) {
                //printf("%.*S\n", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S [PID:%#5d : %s]\n",
                  PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                  handle.HandleValue,
                  handle.Object,
                  handle.GrantedAccess,    
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    objectName.Length / 2,    
                    objectName.Buffer,
                  procID,
                  (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }    
            }
            else {
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                // The object has no name.
                if (wcscmp(handleType, L"Key") == 0) {
                    printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: (unnamed)\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: [PID:%#5d : %s]\n",
                    PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                    handle.HandleValue,
                    handle.Object,
                    handle.GrantedAccess,
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    procID,
                    (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }
            }
        }
    }
    void FilterForTokenHandlers(PSYSTEM_HANDLE_INFORMATION memoryHandlers){
        pNtDuplicateObject = (NtDuplicateObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtDuplicateObject");
        pNtQueryObject = (NtQueryObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryObject");
        HANDLE hProcess;
        char procHostPath[MAX_PATH];
        NTSTATUS status;
        ULONG i;
        char procNameTemp[MAX_PATH];
        // printf(memoryHandlers->NumberOfHandles);
        cout << "Process Name" << "\t" << "Process ID" << "\t" << "Handle Value" << "\t" << "Granted Access" << "\t" << "Handle Type" << "\t" << endl;          
        cout << "------------" << "\t" << "----------" << "\t" << "------------" << "\t" << "-------------" << "\t" << "-----------" << "\t" << endl;
        for(i=0; i < memoryHandlers->NumberOfHandles; i++){
            SYSTEM_HANDLE_TABLE_ENTRY_INFO handle = memoryHandlers->Handles[i];
            HANDLE duplicatedHandle = NULL;
            POBJECT_TYPE_INFORMATION objectTypeInfo;
            PVOID objectNameInfo;
            UNICODE_STRING objectName;
            ULONG returnLength;
            if(!(hProcess = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, handle.UniqueProcessId))){
                //cout << "Failed to open process" << endl;
                continue;                
            }
            GetProcessImageFileNameA(hProcess,procHostPath,MAX_PATH);
            NTSTATUS status = pNtDuplicateObject(hProcess, (void *) handle.HandleValue, GetCurrentProcess(), &duplicatedHandle, 0, 0, DUPLICATE_SAME_ACCESS);
            if (!NT_SUCCESS(status)) {
                CloseHandle(hProcess);
                continue;
            }
            
            objectTypeInfo = (POBJECT_TYPE_INFORMATION) malloc(0x1000);
            if (status=(pNtQueryObject(duplicatedHandle, ObjectTypeInformation, objectTypeInfo, 0x1000, &returnLength))){
                //cout << status << endl;
                CloseHandle(hProcess);
                continue;   
            }
            objectNameInfo = malloc(0x1000);
            if(!NT_SUCCESS(pNtQueryObject(duplicatedHandle, ObjectNameInformation, objectNameInfo, 0x1000 ,&returnLength))){    
                objectNameInfo = realloc(objectNameInfo, returnLength);
            }
            objectName = *(PUNICODE_STRING) objectNameInfo;
            int procID = 0;
            if (objectName.Length) {
                // The object has a name.
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                if (wcscmp(handleType, L"Token") == 0) {
                //printf("%.*S\n", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: %.*S [PID:%#5d : %s]\n",
                  PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                  handle.HandleValue,
                  handle.Object,
                  handle.GrantedAccess,    
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    objectName.Length / 2,    
                    objectName.Buffer,
                  procID,
                  (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }    
            }
            else {
                wchar_t handleType[256];
                swprintf(handleType, sizeof(handleType) / sizeof(handleType[0]), L"%.*S", objectTypeInfo->Name.Length / 2, objectTypeInfo->Name.Buffer);
                // The object has no name.
                if (wcscmp(handleType, L"Token") == 0) {
                    printf(procID == 0 ? "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: (unnamed)\n" : "[HP:%#25s : %#5d] [%#7x]  (0x%p) %#10x %.*S: [PID:%#5d : %s]\n",
                    PathFindFileNameA(procHostPath),
                    GetProcessId(hProcess),
                    handle.HandleValue,
                    handle.Object,
                    handle.GrantedAccess,
                    objectTypeInfo->Name.Length / 2,
                    objectTypeInfo->Name.Buffer,
                    procID,
                    (procID != 0) ? PathFindFileNameA(procNameTemp) : "non existent?");
                }
            }
        }
    }
};