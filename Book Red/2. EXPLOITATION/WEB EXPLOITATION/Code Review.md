## Whitebox Methodology:

	Method 1: review critical unauthenticated functionality (login, password reset, etc.) - *Understand the Flow*
        Focus on custom imports/functions/libraries!
        Logic flaws
            fail-open - wrong order of checks/not recursive, etc. - look for redirects like header("Location: page2.php"); without exit() or die() after
                Especially with PHP
            ex. not throwing an error if authentication check fails
            Redirects are optional! - if no error or die(), you can bypass
                ex.  header("Location:...")
    Method 2: Trace User-Controllable Data - see how it's processed
    Method 3: Search for common vulnerable functions - accessible by user input?
	Process:
        follow sources and sinks
        Top-down approach: sources - likely to uncover lower-severity vulnerabilities with a higher likelihood of exposure
        Bottom-up approach: sinks - more likely to result in higher-severity vulnerabilities with a lower likelihood of exposure
        Goal: identify vulnerabilities or logic errors in the application, determine how to call the vulnerable code, and bypass restrictions
        USE AN IDE - easy for searching code
    Checks:
        • After checking unauthenticated areas, focus on areas of the application that are likely to receive less attention (i.e. authenticated portions of the application).
        • Investigate how sanitization of the user input is performed. Is it done using a trusted, open-source library, or is a custom solution in place?
        • If the application uses a database, how are queries constructed? Does the application parameterize input or simply sanitize it?
        • Inspect the logic for account creation or password reset/recovery routines. Can the functionality be subverted?
        • Does the application interact with its operating system? If so, can we modify commands or inject new ones?
        • Are there programming language-specific vulnerabilities? 

## Checks:

    *Also check Application Language Files*
    Tips:
        Look for custom imports/libraries/functionality! - input sanitization, etc.
        Watch for parameters you can manually specific in GET/POST - See if you can take advantage of unset parameters that are checked
    Comments:
        egrep -R '\/\/|\/\*|\#' .
    Backdoor passwords:  
        egrep -iR '\.equals\(|key|token|secret|api.*key|backdoor' .
    SQLI:
        Look for non-paramaterized (concatenated) SQL queries that I control - Unsanitized (OR incorrectly sanitized!)
        Code Search:
            egrep -iR 'query|qry|search' .
            egrep -R 'SELECT|INSERT|DELETE|WHERE|ORDER BY' .
            egrep -R 'AND|OR' .
            egrep -iR 'where.*\+|select.*\+|query.*\+|qry.*\+|sql.*\+' .
            grep -iR 'multi=True' .
            ^.*?query.*?select.*?
            ^.*?query.*?select.*?where.*?\+.*?
            = *[\.\+]*.*['"][%s]*.*(SELECT|UPDATE|INSERT|DELETE|WHERE|ORDER).*[%s]*['"] *[\.\+]
    XSS:
        egrep -iR 'document.write|setInterval|setTimeout|InnerHtml *=' .
    XXE:
        egrep -iR 'xml' .
    SSTI:
        egrep -iR 'templat|render|engine' .
        egrep -iR '|razor|groovy|jinja|twig|smarty|velocity|freemaker|mako|tornado|jade|rage|pug' .
    Mass Assignment/Parameter Binding (Sensitive Fields): 
        Examine code for account creation, etc. & check API fields - any extra parameters we can set in the url?
        If user POST request is sent to the API directly
        ex. setting isAdmin for account creation url parameter
        Check: signup forms, profile update forms, etc.
        https://github.com/blabla1337/skf-labs/blob/8e89889e8c036fba1c26f028ac07741fa5a8559c/md/Java/kbid-147-Parameter-Binding.md
        https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Mass_Assignment_Cheat_Sheet.md
        Burpsuite Param Miner extension for guessing json parameters
    Deserialization:  *Check by language
        Search for serialize modules used; Google for known vulnerabilities!
        Look for untrusted data that's being deserialized; look for something being serialized or deserialized that you can control the type of, or its data
        Method 1: transmitted object that you can edit
        Method 2: stored object that you can edit
        Look for base64-encoded objects! - serialized objects in transit that can be modified - check known signatures         
        Process: study the source code to identify a class that contains a magic method that is invoked during deserialization. Assess the code that this magic method executes to see if it directly does anything dangerous with user-controllable attributes
            Study any methods the kick-off gadget invokes--anything dangerous w/ data I control? - keep following
            After finding a vulnerability in the code, look for functions you can take advantage of (download, write, etc.) (or use a known gadget)
        3 Conditions:
            The serialized object is provided by or can be modified by a user.
            An application attempts to deserialize and use the object without validation.
            The object is deserialized by a portion of the application with valuable libraries in the "class path".